/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/numeral";
exports.ids = ["vendor-chunks/numeral"];
exports.modules = {

/***/ "(ssr)/./node_modules/numeral/numeral.js":
/*!*****************************************!*\
  !*** ./node_modules/numeral/numeral.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */ (function(global, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function() {\n    /************************************\n        Variables\n    ************************************/ var numeral, _, VERSION = \"2.0.6\", formats = {}, locales = {}, defaults = {\n        currentLocale: \"en\",\n        zeroFormat: null,\n        nullFormat: null,\n        defaultFormat: \"0,0\",\n        scalePercentBy100: true\n    }, options = {\n        currentLocale: defaults.currentLocale,\n        zeroFormat: defaults.zeroFormat,\n        nullFormat: defaults.nullFormat,\n        defaultFormat: defaults.defaultFormat,\n        scalePercentBy100: defaults.scalePercentBy100\n    };\n    /************************************\n        Constructors\n    ************************************/ // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n        this._value = number;\n    }\n    numeral = function(input) {\n        var value, kind, unformatFunction, regexp;\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === \"undefined\") {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === \"string\") {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, \"\").length) {\n                value = null;\n            } else {\n                for(kind in formats){\n                    regexp = typeof formats[kind].regexps.unformat === \"function\" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n                        break;\n                    }\n                }\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input) || null;\n        }\n        return new Numeral(input, value);\n    };\n    // version number\n    numeral.version = VERSION;\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = \"\", trillion = 1000000000000, billion = 1000000000, million = 1000000, thousand = 1000, decimal = \"\", neg = false, abbrForce, abs, min, max, power, int, precision, signed, thousands, output;\n            // make sure we never format a null value\n            value = value || 0;\n            abs = Math.abs(value);\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, \"(\")) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, \"\");\n            } else if (numeral._.includes(format, \"+\") || numeral._.includes(format, \"-\")) {\n                signed = numeral._.includes(format, \"+\") ? format.indexOf(\"+\") : value < 0 ? format.indexOf(\"-\") : -1;\n                format = format.replace(/[\\+|\\-]/g, \"\");\n            }\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, \"a\")) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n                abbrForce = abbrForce ? abbrForce[1] : false;\n                // check for space before abbreviation\n                if (numeral._.includes(format, \" a\")) {\n                    abbr = \" \";\n                }\n                format = format.replace(new RegExp(abbr + \"a[kmbt]?\"), \"\");\n                if (abs >= trillion && !abbrForce || abbrForce === \"t\") {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === \"b\") {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === \"m\") {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === \"k\") {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n            // check for optional decimals\n            if (numeral._.includes(format, \"[.]\")) {\n                optDec = true;\n                format = format.replace(\"[.]\", \".\");\n            }\n            // break number and format\n            int = value.toString().split(\".\")[0];\n            precision = format.split(\".\")[1];\n            thousands = format.indexOf(\",\");\n            leadingCount = (format.split(\".\")[0].split(\",\")[0].match(/0/g) || []).length;\n            if (precision) {\n                if (numeral._.includes(precision, \"[\")) {\n                    precision = precision.replace(\"]\", \"\");\n                    precision = precision.split(\"[\");\n                    decimal = numeral._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n                int = decimal.split(\".\")[0];\n                if (numeral._.includes(decimal, \".\")) {\n                    decimal = locale.delimiters.decimal + decimal.split(\".\")[1];\n                } else {\n                    decimal = \"\";\n                }\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = \"\";\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n                switch(abbr){\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n            // format number\n            if (numeral._.includes(int, \"-\")) {\n                int = int.slice(1);\n                neg = true;\n            }\n            if (int.length < leadingCount) {\n                for(var i = leadingCount - int.length; i > 0; i--){\n                    int = \"0\" + int;\n                }\n            }\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1\" + locale.delimiters.thousands);\n            }\n            if (format.indexOf(\".\") === 0) {\n                int = \"\";\n            }\n            output = int + decimal + (abbr ? abbr : \"\");\n            if (negP) {\n                output = (negP && neg ? \"(\" : \"\") + output + (negP && neg ? \")\" : \"\");\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? \"-\" : \"+\") + output : output + (neg ? \"-\" : \"+\");\n                } else if (neg) {\n                    output = \"-\" + output;\n                }\n            }\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {\n                thousand: 3,\n                million: 6,\n                billion: 9,\n                trillion: 12\n            }, abbreviation, value, i, regexp;\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, \"\").length) {\n                value = null;\n            } else {\n                value = 1;\n                if (locale.delimiters.decimal !== \".\") {\n                    string = string.replace(/\\./g, \"\").replace(locale.delimiters.decimal, \".\");\n                }\n                for(abbreviation in abbreviations){\n                    regexp = new RegExp(\"[^a-zA-Z]\" + locale.abbreviations[abbreviation] + \"(?:\\\\)|(\\\\\" + locale.currency.symbol + \")?(?:\\\\))?)?$\");\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n                // check for negative number\n                value *= (string.split(\"-\").length + Math.min(string.split(\"(\").length - 1, string.split(\")\").length - 1)) % 2 ? 1 : -1;\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, \"\");\n                value *= Number(string);\n            }\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === \"number\" && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/ ) {\n            if (this === null) {\n                throw new TypeError(\"Array.prototype.reduce called on null or undefined\");\n            }\n            if (typeof callback !== \"function\") {\n                throw new TypeError(callback + \" is not a function\");\n            }\n            var t = Object(array), len = t.length >>> 0, k = 0, value;\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while(k < len && !(k in t)){\n                    k++;\n                }\n                if (k >= len) {\n                    throw new TypeError(\"Reduce of empty array with no initial value\");\n                }\n                value = t[k++];\n            }\n            for(; k < len; k++){\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */ multiplier: function(x) {\n            var parts = x.toString().split(\".\");\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */ correctionFactor: function() {\n            var args = Array.prototype.slice.call(arguments);\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */ toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split(\".\"), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n                boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n                boundedPrecision = minDecimals;\n            }\n            power = Math.pow(10, boundedPrecision);\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + \"e+\" + boundedPrecision) / power).toFixed(boundedPrecision);\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp(\"\\\\.?0{1,\" + (optionals - (maxDecimals - boundedPrecision)) + \"}$\");\n                output = output.replace(optionalsRegExp, \"\");\n            }\n            return output;\n        }\n    };\n    // avaliable options\n    numeral.options = options;\n    // avaliable formats\n    numeral.formats = formats;\n    // avaliable formats\n    numeral.locales = locales;\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n        return options.currentLocale;\n    };\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n        key = key.toLowerCase();\n        if (!locales[key]) {\n            throw new Error(\"Unknown locale : \" + key);\n        }\n        return locales[key];\n    };\n    numeral.reset = function() {\n        for(var property in defaults){\n            options[property] = defaults[property];\n        }\n    };\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof format === \"string\" ? format : null;\n    };\n    numeral.nullFormat = function(format) {\n        options.nullFormat = typeof format === \"string\" ? format : null;\n    };\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof format === \"string\" ? format : \"0.0\";\n    };\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n        if (this[type + \"s\"][name]) {\n            throw new TypeError(name + \" \" + type + \" already registered.\");\n        }\n        this[type + \"s\"][name] = format;\n        return format;\n    };\n    numeral.validate = function(val, culture) {\n        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;\n        //coerce val to string\n        if (typeof val !== \"string\") {\n            val += \"\";\n            if (console.warn) {\n                console.warn(\"Numeral.js: Value is not string. It has been co-erced to: \", val);\n            }\n        }\n        //trim whitespaces from either sides\n        val = val.trim();\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n        //if val is empty return false\n        if (val === \"\") {\n            return false;\n        }\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === \".\") {\n            _thousandSep = \"\\\\.\";\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n        _thousandRegEx = new RegExp(_thousandSep + \"{2}\");\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx);\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return !!_valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n                    } else {\n                        return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /************************************\n        Numeral Prototype\n    ************************************/ numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for(kind in formats){\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n                        break;\n                    }\n                }\n                formatFunction = formatFunction || numeral._.numberToFormat;\n                output = formatFunction(value, format, roundingFunction);\n            }\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback, 0) / corrFactor;\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n            this._value = _.reduce([\n                value\n            ], cback, Math.round(this._value * corrFactor)) / corrFactor;\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback, 1);\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n            this._value = _.reduce([\n                this._value,\n                value\n            ], cback);\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n    /************************************\n        Default Locale && Format\n    ************************************/ numeral.register(\"locale\", \"en\", {\n        delimiters: {\n            thousands: \",\",\n            decimal: \".\"\n        },\n        abbreviations: {\n            thousand: \"k\",\n            million: \"m\",\n            billion: \"b\",\n            trillion: \"t\"\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return ~~(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n        },\n        currency: {\n            symbol: \"$\"\n        }\n    });\n    (function() {\n        numeral.register(\"format\", \"bps\", {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, \" BPS\") ? \" \" : \"\", output;\n                value = value * 10000;\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, \"\");\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                if (numeral._.includes(output, \")\")) {\n                    output = output.split(\"\");\n                    output.splice(-1, 0, space + \"BPS\");\n                    output = output.join(\"\");\n                } else {\n                    output = output + space + \"BPS\";\n                }\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n    })();\n    (function() {\n        var decimal = {\n            base: 1000,\n            suffixes: [\n                \"B\",\n                \"KB\",\n                \"MB\",\n                \"GB\",\n                \"TB\",\n                \"PB\",\n                \"EB\",\n                \"ZB\",\n                \"YB\"\n            ]\n        }, binary = {\n            base: 1024,\n            suffixes: [\n                \"B\",\n                \"KiB\",\n                \"MiB\",\n                \"GiB\",\n                \"TiB\",\n                \"PiB\",\n                \"EiB\",\n                \"ZiB\",\n                \"YiB\"\n            ]\n        };\n        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join(\"|\");\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = \"(\" + unformatRegex.replace(\"B\", \"B(?!PS)\") + \")\";\n        numeral.register(\"format\", \"bytes\", {\n            regexps: {\n                format: /([0\\s]i?b)/,\n                unformat: new RegExp(unformatRegex)\n            },\n            format: function(value, format, roundingFunction) {\n                var output, bytes = numeral._.includes(format, \"ib\") ? binary : decimal, suffix = numeral._.includes(format, \" b\") || numeral._.includes(format, \" ib\") ? \" \" : \"\", power, min, max;\n                // check for space before\n                format = format.replace(/\\s?i?b/, \"\");\n                for(power = 0; power <= bytes.suffixes.length; power++){\n                    min = Math.pow(bytes.base, power);\n                    max = Math.pow(bytes.base, power + 1);\n                    if (value === null || value === 0 || value >= min && value < max) {\n                        suffix += bytes.suffixes[power];\n                        if (min > 0) {\n                            value = value / min;\n                        }\n                        break;\n                    }\n                }\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                return output + suffix;\n            },\n            unformat: function(string) {\n                var value = numeral._.stringToNumber(string), power, bytesMultiplier;\n                if (value) {\n                    for(power = decimal.suffixes.length - 1; power >= 0; power--){\n                        if (numeral._.includes(string, decimal.suffixes[power])) {\n                            bytesMultiplier = Math.pow(decimal.base, power);\n                            break;\n                        }\n                        if (numeral._.includes(string, binary.suffixes[power])) {\n                            bytesMultiplier = Math.pow(binary.base, power);\n                            break;\n                        }\n                    }\n                    value *= bytesMultiplier || 1;\n                }\n                return value;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"currency\", {\n            regexps: {\n                format: /(\\$)/\n            },\n            format: function(value, format, roundingFunction) {\n                var locale = numeral.locales[numeral.options.currentLocale], symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                }, output, symbol, i;\n                // strip format of spaces and $\n                format = format.replace(/\\s?\\$\\s?/, \"\");\n                // format the number\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                // update the before and after based on value\n                if (value >= 0) {\n                    symbols.before = symbols.before.replace(/[\\-\\(]/, \"\");\n                    symbols.after = symbols.after.replace(/[\\-\\)]/, \"\");\n                } else if (value < 0 && !numeral._.includes(symbols.before, \"-\") && !numeral._.includes(symbols.before, \"(\")) {\n                    symbols.before = \"-\" + symbols.before;\n                }\n                // loop through each before symbol\n                for(i = 0; i < symbols.before.length; i++){\n                    symbol = symbols.before[i];\n                    switch(symbol){\n                        case \"$\":\n                            output = numeral._.insert(output, locale.currency.symbol, i);\n                            break;\n                        case \" \":\n                            output = numeral._.insert(output, \" \", i + locale.currency.symbol.length - 1);\n                            break;\n                    }\n                }\n                // loop through each after symbol\n                for(i = symbols.after.length - 1; i >= 0; i--){\n                    symbol = symbols.after[i];\n                    switch(symbol){\n                        case \"$\":\n                            output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                            break;\n                        case \" \":\n                            output = i === symbols.after.length - 1 ? output + \" \" : numeral._.insert(output, \" \", -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                            break;\n                    }\n                }\n                return output;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"exponential\", {\n            regexps: {\n                format: /(e\\+|e-)/,\n                unformat: /(e\\+|e-)/\n            },\n            format: function(value, format, roundingFunction) {\n                var output, exponential = typeof value === \"number\" && !numeral._.isNaN(value) ? value.toExponential() : \"0e+0\", parts = exponential.split(\"e\");\n                format = format.replace(/e[\\+|\\-]{1}0/, \"\");\n                output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n                return output + \"e\" + parts[1];\n            },\n            unformat: function(string) {\n                var parts = numeral._.includes(string, \"e+\") ? string.split(\"e+\") : string.split(\"e-\"), value = Number(parts[0]), power = Number(parts[1]);\n                power = numeral._.includes(string, \"e-\") ? power *= -1 : power;\n                function cback(accum, curr, currI, O) {\n                    var corrFactor = numeral._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);\n                    return num;\n                }\n                return numeral._.reduce([\n                    value,\n                    Math.pow(10, power)\n                ], cback, 1);\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"ordinal\", {\n            regexps: {\n                format: /(o)/\n            },\n            format: function(value, format, roundingFunction) {\n                var locale = numeral.locales[numeral.options.currentLocale], output, ordinal = numeral._.includes(format, \" o\") ? \" \" : \"\";\n                // check for space before\n                format = format.replace(/\\s?o/, \"\");\n                ordinal += locale.ordinal(value);\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                return output + ordinal;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"percentage\", {\n            regexps: {\n                format: /(%)/,\n                unformat: /(%)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, \" %\") ? \" \" : \"\", output;\n                if (numeral.options.scalePercentBy100) {\n                    value = value * 100;\n                }\n                // check for space before %\n                format = format.replace(/\\s?\\%/, \"\");\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n                if (numeral._.includes(output, \")\")) {\n                    output = output.split(\"\");\n                    output.splice(-1, 0, space + \"%\");\n                    output = output.join(\"\");\n                } else {\n                    output = output + space + \"%\";\n                }\n                return output;\n            },\n            unformat: function(string) {\n                var number = numeral._.stringToNumber(string);\n                if (numeral.options.scalePercentBy100) {\n                    return number * 0.01;\n                }\n                return number;\n            }\n        });\n    })();\n    (function() {\n        numeral.register(\"format\", \"time\", {\n            regexps: {\n                format: /(:)/,\n                unformat: /(:)/\n            },\n            format: function(value, format, roundingFunction) {\n                var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);\n                return hours + \":\" + (minutes < 10 ? \"0\" + minutes : minutes) + \":\" + (seconds < 10 ? \"0\" + seconds : seconds);\n            },\n            unformat: function(string) {\n                var timeArray = string.split(\":\"), seconds = 0;\n                // turn hours and minutes into seconds and add them all up\n                if (timeArray.length === 3) {\n                    // hours\n                    seconds = seconds + Number(timeArray[0]) * 60 * 60;\n                    // minutes\n                    seconds = seconds + Number(timeArray[1]) * 60;\n                    // seconds\n                    seconds = seconds + Number(timeArray[2]);\n                } else if (timeArray.length === 2) {\n                    // minutes\n                    seconds = seconds + Number(timeArray[0]) * 60;\n                    // seconds\n                    seconds = seconds + Number(timeArray[1]);\n                }\n                return Number(seconds);\n            }\n        });\n    })();\n    return numeral;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtZXJhbC9udW1lcmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUVBLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN0QixJQUFJLElBQTBDLEVBQUU7UUFDNUNDLG9DQUFPRCxPQUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUNuQixPQUFPLEVBSU47QUFDTCxHQUFFLElBQUksRUFBRTtJQUNKOzt1Q0FFbUMsR0FFbkMsSUFBSUssU0FDQUMsR0FDQUMsVUFBVSxTQUNWQyxVQUFVLENBQUMsR0FDWEMsVUFBVSxDQUFDLEdBQ1hDLFdBQVc7UUFDUEMsZUFBZTtRQUNmQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsZUFBZTtRQUNmQyxtQkFBbUI7SUFDdkIsR0FDQUMsVUFBVTtRQUNOTCxlQUFlRCxTQUFTQyxhQUFhO1FBQ3JDQyxZQUFZRixTQUFTRSxVQUFVO1FBQy9CQyxZQUFZSCxTQUFTRyxVQUFVO1FBQy9CQyxlQUFlSixTQUFTSSxhQUFhO1FBQ3JDQyxtQkFBbUJMLFNBQVNLLGlCQUFpQjtJQUNqRDtJQUdKOzt1Q0FFbUMsR0FFbkMsMkJBQTJCO0lBQzNCLFNBQVNFLFFBQVFDLEtBQUssRUFBRUMsTUFBTTtRQUMxQixJQUFJLENBQUNDLE1BQU0sR0FBR0Y7UUFFZCxJQUFJLENBQUNHLE1BQU0sR0FBR0Y7SUFDbEI7SUFFQWQsVUFBVSxTQUFTYSxLQUFLO1FBQ3BCLElBQUlJLE9BQ0FDLE1BQ0FDLGtCQUNBQztRQUVKLElBQUlwQixRQUFRcUIsU0FBUyxDQUFDUixRQUFRO1lBQzFCSSxRQUFRSixNQUFNSSxLQUFLO1FBQ3ZCLE9BQU8sSUFBSUosVUFBVSxLQUFLLE9BQU9BLFVBQVUsYUFBYTtZQUNwREksUUFBUTtRQUNaLE9BQU8sSUFBSUosVUFBVSxRQUFRWixFQUFFcUIsS0FBSyxDQUFDVCxRQUFRO1lBQ3pDSSxRQUFRO1FBQ1osT0FBTyxJQUFJLE9BQU9KLFVBQVUsVUFBVTtZQUNsQyxJQUFJ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ZV9tb2R1bGVzL251bWVyYWwvbnVtZXJhbC5qcz81YTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAcHJlc2VydmVcbiAqIG51bWVyYWwuanNcbiAqIHZlcnNpb24gOiAyLjAuNlxuICogYXV0aG9yIDogQWRhbSBEcmFwZXJcbiAqIGxpY2Vuc2UgOiBNSVRcbiAqIGh0dHA6Ly9hZGFtd2RyYXBlci5naXRodWIuY29tL051bWVyYWwtanMvXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5udW1lcmFsID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVmFyaWFibGVzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG51bWVyYWwsXG4gICAgICAgIF8sXG4gICAgICAgIFZFUlNJT04gPSAnMi4wLjYnLFxuICAgICAgICBmb3JtYXRzID0ge30sXG4gICAgICAgIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiAnZW4nLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiAnMCwwJyxcbiAgICAgICAgICAgIHNjYWxlUGVyY2VudEJ5MTAwOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiBkZWZhdWx0cy5jdXJyZW50TG9jYWxlLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogZGVmYXVsdHMuemVyb0Zvcm1hdCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IGRlZmF1bHRzLm51bGxGb3JtYXQsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiBkZWZhdWx0cy5kZWZhdWx0Rm9ybWF0LFxuICAgICAgICAgICAgc2NhbGVQZXJjZW50QnkxMDA6IGRlZmF1bHRzLnNjYWxlUGVyY2VudEJ5MTAwXG4gICAgICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbChpbnB1dCwgbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgbnVtZXJhbCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICB1bmZvcm1hdEZ1bmN0aW9uLFxuICAgICAgICAgICAgcmVnZXhwO1xuXG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgXy5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy56ZXJvRm9ybWF0ICYmIGlucHV0ID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBpbnB1dCA9PT0gb3B0aW9ucy5udWxsRm9ybWF0IHx8ICFpbnB1dC5yZXBsYWNlKC9bXjAtOV0rL2csICcnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoa2luZCBpbiBmb3JtYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IHR5cGVvZiBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQoKSA6IGZvcm1hdHNba2luZF0ucmVnZXhwcy51bmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwICYmIGlucHV0Lm1hdGNoKHJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLnVuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSB1bmZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5zdHJpbmdUb051bWJlcjtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5mb3JtYXRGdW5jdGlvbihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihpbnB1dCl8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmFsKGlucHV0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIG51bWVyYWwuXyA9IF8gPSB7XG4gICAgICAgIC8vIGZvcm1hdHMgbnVtYmVycyBzZXBhcmF0b3JzLCBkZWNpbWFscyBwbGFjZXMsIHNpZ25zLCBhYmJyZXZpYXRpb25zXG4gICAgICAgIG51bWJlclRvRm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlc1tudW1lcmFsLm9wdGlvbnMuY3VycmVudExvY2FsZV0sXG4gICAgICAgICAgICAgICAgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgICAgIHRyaWxsaW9uID0gMTAwMDAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBiaWxsaW9uID0gMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBtaWxsaW9uID0gMTAwMDAwMCxcbiAgICAgICAgICAgICAgICB0aG91c2FuZCA9IDEwMDAsXG4gICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnLFxuICAgICAgICAgICAgICAgIG5lZyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgYWJzLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgaW50LFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIG5ldmVyIGZvcm1hdCBhIG51bGwgdmFsdWVcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgMDtcblxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcoJykpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvW1xcKHxcXCldL2csICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSB8fCBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSA/IGZvcm1hdC5pbmRleE9mKCcrJykgOiB2YWx1ZSA8IDAgPyBmb3JtYXQuaW5kZXhPZignLScpIDogLTE7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1tcXCt8XFwtXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb24gaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2EnKSkge1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZvcm1hdC5tYXRjaCgvYShrfG18Ynx0KT8vKTtcblxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJGb3JjZSA/IGFiYnJGb3JjZVsxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKGFiYnIgKyAnYVtrbWJ0XT8nKSwgJycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSB0cmlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgKz0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyB0cmlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IHRyaWxsaW9uICYmIGFicyA+PSBiaWxsaW9uICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyICs9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBiaWxsaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgYmlsbGlvbiAmJiBhYnMgPj0gbWlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IG1pbGxpb24gJiYgYWJzID49IHRob3VzYW5kICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHRob3VzYW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG9wdGlvbmFsIGRlY2ltYWxzXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ1suXScpKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYnJlYWsgbnVtYmVyIGFuZCBmb3JtYXRcbiAgICAgICAgICAgIGludCA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcbiAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IChmb3JtYXQuc3BsaXQoJy4nKVswXS5zcGxpdCgnLCcpWzBdLm1hdGNoKC8wL2cpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKHByZWNpc2lvbiwgJ1snKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSBudW1lcmFsLl8udG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnQgPSBkZWNpbWFsLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGRlY2ltYWwsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkZWNpbWFsLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGRlY2ltYWwuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCAwLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgYWJicmV2aWF0aW9uIGFnYWluIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgICAgICBpZiAoYWJiciAmJiAhYWJickZvcmNlICYmIE51bWJlcihpbnQpID49IDEwMDAgJiYgYWJiciAhPT0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICBpbnQgPSBTdHJpbmcoTnVtYmVyKGludCkgLyAxMDAwKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWJicikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxvY2FsZS5hYmJyZXZpYXRpb25zLnRob3VzYW5kOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5iaWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoaW50LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnQubGVuZ3RoIDwgbGVhZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlYWRpbmdDb3VudCAtIGludC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ID0gJzAnICsgaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgbG9jYWxlLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0ID0gaW50ICsgZGVjaW1hbCArIChhYmJyID8gYWJiciA6ICcnKTtcblxuICAgICAgICAgICAgaWYgKG5lZ1ApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAobmVnUCAmJiBuZWcgPyAnKCcgOiAnJykgKyBvdXRwdXQgKyAobmVnUCAmJiBuZWcgPyAnKScgOiAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzaWduZWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzaWduZWQgPT09IDAgPyAobmVnID8gJy0nIDogJysnKSArIG91dHB1dCA6IG91dHB1dCArIChuZWcgPyAnLScgOiAnKycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICctJyArIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHVuZm9ybWF0cyBudW1iZXJzIHNlcGFyYXRvcnMsIGRlY2ltYWxzIHBsYWNlcywgc2lnbnMsIGFiYnJldmlhdGlvbnNcbiAgICAgICAgc3RyaW5nVG9OdW1iZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdPcmlnaW5hbCA9IHN0cmluZyxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogMyxcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlvbjogNixcbiAgICAgICAgICAgICAgICAgICAgYmlsbGlvbjogOSxcbiAgICAgICAgICAgICAgICAgICAgdHJpbGxpb246IDEyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICByZWdleHA7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnplcm9Gb3JtYXQgJiYgc3RyaW5nID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBzdHJpbmcgPT09IG9wdGlvbnMubnVsbEZvcm1hdCB8fCAhc3RyaW5nLnJlcGxhY2UoL1teMC05XSsvZywgJycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwsICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChhYmJyZXZpYXRpb24gaW4gYWJicmV2aWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbG9jYWxlLmFiYnJldmlhdGlvbnNbYWJicmV2aWF0aW9uXSArICcoPzpcXFxcKXwoXFxcXCcgKyBsb2NhbGUuY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdPcmlnaW5hbC5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAqPSBNYXRoLnBvdygxMCwgYWJicmV2aWF0aW9uc1thYmJyZXZpYXRpb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5lZ2F0aXZlIG51bWJlclxuICAgICAgICAgICAgICAgIHZhbHVlICo9IChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGggLSAxLCBzdHJpbmcuc3BsaXQoJyknKS5sZW5ndGggLSAxKSkgJSAyID8gMSA6IC0xO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vbiBudW1iZXJzXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgKj0gTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOYU46IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHNlYXJjaCkgIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0cmluZywgc3ViU3RyaW5nLCBzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBzdGFydCkgKyBzdWJTdHJpbmcgKyBzdHJpbmcuc2xpY2Uoc3RhcnQpO1xuICAgICAgICB9LFxuICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjayAvKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KGFycmF5KSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBrID0gMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4gJiYgIShrIGluIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdFtrKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChrIGluIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdFtrXSwgaywgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpZXIgbmVjZXNzYXJ5IHRvIG1ha2UgeCA+PSAxLFxuICAgICAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPCAyID8gMSA6IE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgICAgICogYWxsIG9mIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0aW9uRmFjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbihhY2N1bSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtbiA9IF8ubXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gPiBtbiA/IGFjY3VtIDogbW47XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9GaXhlZDogZnVuY3Rpb24odmFsdWUsIG1heERlY2ltYWxzLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIG1pbkRlY2ltYWxzID0gbWF4RGVjaW1hbHMgLSAob3B0aW9uYWxzIHx8IDApLFxuICAgICAgICAgICAgICAgIGJvdW5kZWRQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzbWFsbGVzdCBwcmVjaXNpb24gdmFsdWUgcG9zc2libGUgdG8gYXZvaWQgZXJyb3JzIGZyb20gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIGlmIChzcGxpdFZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICBib3VuZGVkUHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc3BsaXRWYWx1ZVsxXS5sZW5ndGgsIG1pbkRlY2ltYWxzKSwgbWF4RGVjaW1hbHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYm91bmRlZFByZWNpc2lvbiA9IG1pbkRlY2ltYWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3dlciA9IE1hdGgucG93KDEwLCBib3VuZGVkUHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSArICdlKycgKyBib3VuZGVkUHJlY2lzaW9uKSAvIHBvd2VyKS50b0ZpeGVkKGJvdW5kZWRQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uYWxzID4gbWF4RGVjaW1hbHMgLSBib3VuZGVkUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnXFxcXC4/MHsxLCcgKyAob3B0aW9uYWxzIC0gKG1heERlY2ltYWxzIC0gYm91bmRlZFByZWNpc2lvbikpICsgJ30kJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYXZhbGlhYmxlIG9wdGlvbnNcbiAgICBudW1lcmFsLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmZvcm1hdHMgPSBmb3JtYXRzO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmxvY2FsZXMgPSBsb2NhbGVzO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIG51bWVyYWwubG9jYWxlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY3VycmVudExvY2FsZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3VycmVudExvY2FsZTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvYWRlZCBsb2NhbGUgZGF0YS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGdsb2JhbCBsb2NhbGUgb2JqZWN0LlxuICAgIG51bWVyYWwubG9jYWxlRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghbG9jYWxlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbG9jYWxlIDogJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BlcnR5XSA9IGRlZmF1bHRzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBudW1lcmFsLnplcm9Gb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy56ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5udWxsRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBvcHRpb25zLm51bGxGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIG51bWVyYWwucmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAodGhpc1t0eXBlICsgJ3MnXVtuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lICsgJyAnICsgdHlwZSArICcgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1t0eXBlICsgJ3MnXVtuYW1lXSA9IGZvcm1hdDtcblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG5cblxuICAgIG51bWVyYWwudmFsaWRhdGUgPSBmdW5jdGlvbih2YWwsIGN1bHR1cmUpIHtcbiAgICAgICAgdmFyIF9kZWNpbWFsU2VwLFxuICAgICAgICAgICAgX3Rob3VzYW5kU2VwLFxuICAgICAgICAgICAgX2N1cnJTeW1ib2wsXG4gICAgICAgICAgICBfdmFsQXJyYXksXG4gICAgICAgICAgICBfYWJick9iaixcbiAgICAgICAgICAgIF90aG91c2FuZFJlZ0V4LFxuICAgICAgICAgICAgbG9jYWxlRGF0YSxcbiAgICAgICAgICAgIHRlbXA7XG5cbiAgICAgICAgLy9jb2VyY2UgdmFsIHRvIHN0cmluZ1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbCArPSAnJztcblxuICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTnVtZXJhbC5qczogVmFsdWUgaXMgbm90IHN0cmluZy4gSXQgaGFzIGJlZW4gY28tZXJjZWQgdG86ICcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RyaW0gd2hpdGVzcGFjZXMgZnJvbSBlaXRoZXIgc2lkZXNcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcblxuICAgICAgICAvL2lmIHZhbCBpcyBqdXN0IGRpZ2l0cyByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoISF2YWwubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGVtcHR5IHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kcyBzZXBhcmF0b3IgZnJvbSBudW1lcmFsLmxvY2FsZURhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGN1bHR1cmUgaXMgdW5kZXJzdG9vZCBieSBudW1lcmFsLiBpZiBub3QsIGRlZmF1bHQgaXQgdG8gY3VycmVudCBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEoY3VsdHVyZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEobnVtZXJhbC5sb2NhbGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NldHVwIHRoZSBkZWxpbWl0ZXJzIGFuZCBjdXJyZW5jeSBzeW1ib2wgYmFzZWQgb24gY3VsdHVyZS9sb2NhbGVcbiAgICAgICAgX2N1cnJTeW1ib2wgPSBsb2NhbGVEYXRhLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgX2FiYnJPYmogPSBsb2NhbGVEYXRhLmFiYnJldmlhdGlvbnM7XG4gICAgICAgIF9kZWNpbWFsU2VwID0gbG9jYWxlRGF0YS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgIGlmIChsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzID09PSAnLicpIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9ICdcXFxcLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAgPSBsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWRhdGluZyBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvXlteXFxkXSsvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAodGVtcFswXSAhPT0gX2N1cnJTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZhbGlkYXRpbmcgYWJicmV2aWF0aW9uIHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9bXlxcZF0rJC8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfYWJick9iai50aG91c2FuZCAmJiB0ZW1wWzBdICE9PSBfYWJick9iai5taWxsaW9uICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLmJpbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmoudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhvdXNhbmRSZWdFeCA9IG5ldyBSZWdFeHAoX3Rob3VzYW5kU2VwICsgJ3syfScpO1xuXG4gICAgICAgIGlmICghdmFsLm1hdGNoKC9bXlxcZC4sXS9nKSkge1xuICAgICAgICAgICAgX3ZhbEFycmF5ID0gdmFsLnNwbGl0KF9kZWNpbWFsU2VwKTtcbiAgICAgICAgICAgIGlmIChfdmFsQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCsuKlxcZCQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCskLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhISBfdmFsQXJyYXlbMF0ubWF0Y2goL15cXGQrLipcXGQkLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwuZm4gPSBOdW1lcmFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5wdXRTdHJpbmcsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGlucHV0U3RyaW5nIHx8IG9wdGlvbnMuZGVmYXVsdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbjtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSByb3VuZGluZ0Z1bmN0aW9uXG4gICAgICAgICAgICByb3VuZGluZ0Z1bmN0aW9uID0gcm91bmRpbmdGdW5jdGlvbiB8fCBNYXRoLnJvdW5kO1xuXG4gICAgICAgICAgICAvLyBmb3JtYXQgYmFzZWQgb24gdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBvcHRpb25zLnplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLnplcm9Gb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbEZvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMubnVsbEZvcm1hdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChraW5kIGluIGZvcm1hdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5tYXRjaChmb3JtYXRzW2tpbmRdLnJlZ2V4cHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdDtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDApIC8gY29yckZhY3RvcjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdmFsdWVdLCBjYmFjaywgTWF0aC5yb3VuZCh0aGlzLl92YWx1ZSAqIGNvcnJGYWN0b3IpKSAvIGNvcnJGYWN0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gXy5jb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhY2N1bSAqIGNvcnJGYWN0b3IpICogTWF0aC5yb3VuZChjdXJyICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFjY3VtICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2spO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGlmZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExvY2FsZSAmJiBGb3JtYXRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsLnJlZ2lzdGVyKCdsb2NhbGUnLCAnZW4nLCB7XG4gICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIGFiYnJldmlhdGlvbnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICBiaWxsaW9uOiAnYicsXG4gICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ2JwcycsIHtcbiAgICAgICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IC8oQlBTKS8sXG4gICAgICAgICAgICAgICAgdW5mb3JtYXQ6IC8oQlBTKS9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnIEJQUycpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxMDAwMDtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgQlBTXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xccz9CUFMvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJ0JQUycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICdCUFMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiArKG51bWVyYWwuXy5zdHJpbmdUb051bWJlcihzdHJpbmcpICogMC4wMDAxKS50b0ZpeGVkKDE1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY2ltYWwgPSB7XG4gICAgICAgICAgICBiYXNlOiAxMDAwLFxuICAgICAgICAgICAgc3VmZml4ZXM6IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG4gICAgICAgIH0sXG4gICAgICAgIGJpbmFyeSA9IHtcbiAgICAgICAgICAgIGJhc2U6IDEwMjQsXG4gICAgICAgICAgICBzdWZmaXhlczogWydCJywgJ0tpQicsICdNaUInLCAnR2lCJywgJ1RpQicsICdQaUInLCAnRWlCJywgJ1ppQicsICdZaUInXVxuICAgICAgICB9O1xuXG4gICAgdmFyIGFsbFN1ZmZpeGVzID0gIGRlY2ltYWwuc3VmZml4ZXMuY29uY2F0KGJpbmFyeS5zdWZmaXhlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsLnN1ZmZpeGVzLmluZGV4T2YoaXRlbSkgPCAwO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB1bmZvcm1hdFJlZ2V4ID0gYWxsU3VmZml4ZXMuam9pbignfCcpO1xuICAgICAgICAvLyBBbGxvdyBzdXBwb3J0IGZvciBCUFMgKGh0dHA6Ly93d3cuaW52ZXN0b3BlZGlhLmNvbS90ZXJtcy9iL2Jhc2lzcG9pbnQuYXNwKVxuICAgICAgICB1bmZvcm1hdFJlZ2V4ID0gJygnICsgdW5mb3JtYXRSZWdleC5yZXBsYWNlKCdCJywgJ0IoPyFQUyknKSArICcpJztcblxuICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdieXRlcycsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKFswXFxzXWk/YikvLFxuICAgICAgICAgICAgdW5mb3JtYXQ6IG5ldyBSZWdFeHAodW5mb3JtYXRSZWdleClcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGJ5dGVzID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2liJykgPyBiaW5hcnkgOiBkZWNpbWFsLFxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgYicpIHx8IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgaWInKSA/ICcgJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/aT9iLywgJycpO1xuXG4gICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gYnl0ZXMuc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coYnl0ZXMuYmFzZSwgcG93ZXIpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KGJ5dGVzLmJhc2UsIHBvd2VyICsgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IDAgfHwgdmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCArPSBieXRlcy5zdWZmaXhlc1twb3dlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIHN1ZmZpeDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyksXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gZGVjaW1hbC5zdWZmaXhlcy5sZW5ndGggLSAxOyBwb3dlciA+PSAwOyBwb3dlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBkZWNpbWFsLnN1ZmZpeGVzW3Bvd2VyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IE1hdGgucG93KGRlY2ltYWwuYmFzZSwgcG93ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBiaW5hcnkuc3VmZml4ZXNbcG93ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gTWF0aC5wb3coYmluYXJ5LmJhc2UsIHBvd2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSAqPSAoYnl0ZXNNdWx0aXBsaWVyIHx8IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAnY3VycmVuY3knLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhcXCQpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBudW1lcmFsLmxvY2FsZXNbbnVtZXJhbC5vcHRpb25zLmN1cnJlbnRMb2NhbGVdLFxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogZm9ybWF0Lm1hdGNoKC9eKFtcXCt8XFwtfFxcKHxcXHN8XFwkXSopLylbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyOiBmb3JtYXQubWF0Y2goLyhbXFwrfFxcLXxcXCl8XFxzfFxcJF0qKSQvKVswXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAvLyBzdHJpcCBmb3JtYXQgb2Ygc3BhY2VzIGFuZCAkXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJFxccz8vLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYmVmb3JlIGFuZCBhZnRlciBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9IHN5bWJvbHMuYmVmb3JlLnJlcGxhY2UoL1tcXC1cXChdLywgJycpO1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYWZ0ZXIgPSBzeW1ib2xzLmFmdGVyLnJlcGxhY2UoL1tcXC1cXCldLywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDAgJiYgKCFudW1lcmFsLl8uaW5jbHVkZXMoc3ltYm9scy5iZWZvcmUsICctJykgJiYgIW51bWVyYWwuXy5pbmNsdWRlcyhzeW1ib2xzLmJlZm9yZSwgJygnKSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9ICctJyArIHN5bWJvbHMuYmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBiZWZvcmUgc3ltYm9sXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9scy5iZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xzLmJlZm9yZVtpXTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsICcgJywgaSArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGFmdGVyIHN5bWJvbFxuICAgICAgICAgICAgZm9yIChpID0gc3ltYm9scy5hZnRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbHMuYWZ0ZXJbaV07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wgOiBudW1lcmFsLl8uaW5zZXJ0KG91dHB1dCwgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbCwgLShzeW1ib2xzLmFmdGVyLmxlbmd0aCAtICgxICsgaSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArICcgJyA6IG51bWVyYWwuXy5pbnNlcnQob3V0cHV0LCAnICcsIC0oc3ltYm9scy5hZnRlci5sZW5ndGggLSAoMSArIGkpICsgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdleHBvbmVudGlhbCcsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKGVcXCt8ZS0pLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKGVcXCt8ZS0pL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQsXG4gICAgICAgICAgICAgICAgZXhwb25lbnRpYWwgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFudW1lcmFsLl8uaXNOYU4odmFsdWUpID8gdmFsdWUudG9FeHBvbmVudGlhbCgpIDogJzBlKzAnLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gZXhwb25lbnRpYWwuc3BsaXQoJ2UnKTtcblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL2VbXFwrfFxcLV17MX0wLywgJycpO1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQoTnVtYmVyKHBhcnRzWzBdKSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArICdlJyArIHBhcnRzWzFdO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCAnZSsnKSA/IHN0cmluZy5zcGxpdCgnZSsnKSA6IHN0cmluZy5zcGxpdCgnZS0nKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihwYXJ0c1swXSksXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBOdW1iZXIocGFydHNbMV0pO1xuXG4gICAgICAgICAgICBwb3dlciA9IG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsICdlLScpID8gcG93ZXIgKj0gLTEgOiBwb3dlcjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBudW1lcmFsLl8uY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3VyciksXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwuXy5yZWR1Y2UoW3ZhbHVlLCBNYXRoLnBvdygxMCwgcG93ZXIpXSwgY2JhY2ssIDEpO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ29yZGluYWwnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhvKS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbnVtZXJhbC5sb2NhbGVzW251bWVyYWwub3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgb3JkaW5hbCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgbycpID8gJyAnIDogJyc7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/by8sICcnKTtcblxuICAgICAgICAgICAgb3JkaW5hbCArPSBsb2NhbGUub3JkaW5hbCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIG9yZGluYWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAncGVyY2VudGFnZScsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKCUpLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKCUpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgJScpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJS8sICcnKTtcblxuICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciAqIDAuMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ3RpbWUnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyg6KS8sXG4gICAgICAgICAgICB1bmZvcm1hdDogLyg6KS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKHZhbHVlIC8gNjAgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpIC8gNjApLFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBob3VycyArICc6JyArIChtaW51dGVzIDwgMTAgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgKyAoc2Vjb25kcyA8IDEwID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHR1cm4gaG91cnMgYW5kIG1pbnV0ZXMgaW50byBzZWNvbmRzIGFuZCBhZGQgdGhlbSBhbGwgdXBcbiAgICAgICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwICogNjApO1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cbnJldHVybiBudW1lcmFsO1xufSkpO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwibnVtZXJhbCIsIl8iLCJWRVJTSU9OIiwiZm9ybWF0cyIsImxvY2FsZXMiLCJkZWZhdWx0cyIsImN1cnJlbnRMb2NhbGUiLCJ6ZXJvRm9ybWF0IiwibnVsbEZvcm1hdCIsImRlZmF1bHRGb3JtYXQiLCJzY2FsZVBlcmNlbnRCeTEwMCIsIm9wdGlvbnMiLCJOdW1lcmFsIiwiaW5wdXQiLCJudW1iZXIiLCJfaW5wdXQiLCJfdmFsdWUiLCJ2YWx1ZSIsImtpbmQiLCJ1bmZvcm1hdEZ1bmN0aW9uIiwicmVnZXhwIiwiaXNOdW1lcmFsIiwiaXNOYU4iLCJyZXBsYWNlIiwibGVuZ3RoIiwicmVnZXhwcyIsInVuZm9ybWF0IiwibWF0Y2giLCJzdHJpbmdUb051bWJlciIsIk51bWJlciIsInZlcnNpb24iLCJvYmoiLCJudW1iZXJUb0Zvcm1hdCIsImZvcm1hdCIsInJvdW5kaW5nRnVuY3Rpb24iLCJsb2NhbGUiLCJuZWdQIiwib3B0RGVjIiwibGVhZGluZ0NvdW50IiwiYWJiciIsInRyaWxsaW9uIiwiYmlsbGlvbiIsIm1pbGxpb24iLCJ0aG91c2FuZCIsImRlY2ltYWwiLCJuZWciLCJhYmJyRm9yY2UiLCJhYnMiLCJtaW4iLCJtYXgiLCJwb3dlciIsImludCIsInByZWNpc2lvbiIsInNpZ25lZCIsInRob3VzYW5kcyIsIm91dHB1dCIsIk1hdGgiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJSZWdFeHAiLCJhYmJyZXZpYXRpb25zIiwidG9TdHJpbmciLCJzcGxpdCIsInRvRml4ZWQiLCJkZWxpbWl0ZXJzIiwic2xpY2UiLCJTdHJpbmciLCJpIiwic3RyaW5nIiwic3RyaW5nT3JpZ2luYWwiLCJhYmJyZXZpYXRpb24iLCJjdXJyZW5jeSIsInN5bWJvbCIsInBvdyIsInNlYXJjaCIsImluc2VydCIsInN1YlN0cmluZyIsInN0YXJ0IiwicmVkdWNlIiwiYXJyYXkiLCJjYWxsYmFjayIsIlR5cGVFcnJvciIsInQiLCJPYmplY3QiLCJsZW4iLCJrIiwiYXJndW1lbnRzIiwibXVsdGlwbGllciIsIngiLCJwYXJ0cyIsImNvcnJlY3Rpb25GYWN0b3IiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYWNjdW0iLCJuZXh0IiwibW4iLCJtYXhEZWNpbWFscyIsIm9wdGlvbmFscyIsInNwbGl0VmFsdWUiLCJtaW5EZWNpbWFscyIsImJvdW5kZWRQcmVjaXNpb24iLCJvcHRpb25hbHNSZWdFeHAiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZURhdGEiLCJFcnJvciIsInJlc2V0IiwicHJvcGVydHkiLCJyZWdpc3RlciIsInR5cGUiLCJuYW1lIiwidmFsaWRhdGUiLCJ2YWwiLCJjdWx0dXJlIiwiX2RlY2ltYWxTZXAiLCJfdGhvdXNhbmRTZXAiLCJfY3VyclN5bWJvbCIsIl92YWxBcnJheSIsIl9hYmJyT2JqIiwiX3Rob3VzYW5kUmVnRXgiLCJ0ZW1wIiwiY29uc29sZSIsIndhcm4iLCJ0cmltIiwiZSIsInN1YnN0ciIsImZuIiwiY2xvbmUiLCJpbnB1dFN0cmluZyIsImZvcm1hdEZ1bmN0aW9uIiwicm91bmQiLCJzZXQiLCJhZGQiLCJjb3JyRmFjdG9yIiwiY2JhY2siLCJjdXJyIiwiY3VyckkiLCJPIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImRpdmlkZSIsImRpZmZlcmVuY2UiLCJvcmRpbmFsIiwiYiIsInNwYWNlIiwic3BsaWNlIiwiam9pbiIsImJhc2UiLCJzdWZmaXhlcyIsImJpbmFyeSIsImFsbFN1ZmZpeGVzIiwiY29uY2F0IiwiZmlsdGVyIiwiaXRlbSIsInVuZm9ybWF0UmVnZXgiLCJieXRlcyIsInN1ZmZpeCIsImJ5dGVzTXVsdGlwbGllciIsInN5bWJvbHMiLCJiZWZvcmUiLCJhZnRlciIsImV4cG9uZW50aWFsIiwidG9FeHBvbmVudGlhbCIsIm51bSIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIiwic2Vjb25kcyIsInRpbWVBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/numeral/numeral.js\n");

/***/ })

};
;