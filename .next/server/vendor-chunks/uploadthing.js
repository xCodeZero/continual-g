"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generatePermittedFileTypes),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n\n\nvar version$1 = \"6.6.0\";\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        let customHeaders = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n        if (customHeaders instanceof Promise) customHeaders = await customHeaders;\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package,\n                \"x-uploadthing-version\": version$1,\n                ...customHeaders\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        if (!response.ok) {\n            const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(response);\n            throw error;\n        }\n        const jsonOrError = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(response);\n        if (jsonOrError instanceof Error) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: response\n            });\n        }\n        return jsonOrError;\n    };\n};\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst uploadFilesInternal = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch,\n        headers: opts.headers\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n        }\n        let serverData = null;\n        if (!opts.skipPolling) {\n            serverData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.withExponentialBackoff)(async ()=>{\n                const res = await fetch(presigned.pollingUrl, {\n                    headers: {\n                        authorization: presigned.pollingJwt\n                    }\n                }).then((r)=>r.json());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return res.status === \"done\" ? res.callbackData : undefined;\n            });\n        }\n        return {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            key: presigned.key,\n            url: \"https://utfs.io/f/\" + presigned.key,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            serverData: serverData,\n            customId: presigned.customId\n        };\n    });\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    return (endpoint, opts)=>uploadFilesInternal(endpoint, {\n            ...opts,\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(initOpts?.url),\n            package: initOpts.package\n        });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    }).catch((res)=>{\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\",\n            cause: res\n        });\n    });\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = ()=>resolve({\n                status: xhr.status\n            });\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    }).catch(async (error)=>{\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    });\n    if (response.status > 299 || response.status < 200) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name\n        });\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzSTtBQUNwQjtBQUVsSCxJQUFJUSxZQUFZO0FBRWhCLE1BQU1DLHdCQUF3QixDQUFDQztJQUMzQixNQUFNQyxZQUFZRCxTQUFTRSxLQUFLLENBQUM7SUFDakMsTUFBTUMsZUFBZUgsU0FBU0UsS0FBSyxDQUFDO0lBQ3BDLE1BQU1FLE9BQU9ILFdBQVcsQ0FBQyxFQUFFO0lBQzNCLE1BQU1JLFVBQVVGLGNBQWMsQ0FBQyxFQUFFO0lBQ2pDLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxTQUFTLE9BQU87SUFDOUIsT0FBTztRQUNIRCxNQUFNRSx1QkFBdUIsQ0FBQ0YsS0FBSyxJQUFJRztRQUN2Q0Y7SUFDSjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQUcsTUFBTUUscUJBQXFCO0FBQy9CLE1BQU1ELDBCQUEwQjtJQUM1QkUsY0FBYztJQUNkQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUNoQkMsY0FBYztJQUNkQyxxQ0FBcUM7SUFDckNDLGVBQWU7SUFDZkMsaUJBQWlCO0lBQ2pCQywwQkFBMEI7QUFDOUI7QUFFQTs7O0NBR0MsR0FBRyxlQUFlQyx1QkFBdUJDLElBQUksRUFBRUMsYUFBYSxDQUFDO0lBQzFELE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUN6QixNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxJQUFJLENBQUMsT0FBT1AsS0FBS1EsR0FBRyxFQUFFO1FBQzFCSCxJQUFJSSxnQkFBZ0IsQ0FBQyxnQkFBZ0JULEtBQUtVLFFBQVE7UUFDbERMLElBQUlJLGdCQUFnQixDQUFDLHVCQUF1QnBDLHVFQUFrQkEsQ0FBQzJCLEtBQUszQixrQkFBa0IsRUFBRTJCLEtBQUtXLFFBQVE7UUFDckdOLElBQUlPLE1BQU0sR0FBRztZQUNULElBQUlQLElBQUlRLE1BQU0sSUFBSSxPQUFPUixJQUFJUSxNQUFNLEdBQUcsS0FBSztn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QyxRQUFRaEQsT0FBTyw2QkFBNkI7SUFDNUQsTUFBTWpDLFdBQVcsTUFBTSxJQUFJL0MsUUFBUSxDQUFDQyxTQUFTQztRQUN6QyxNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxJQUFJLENBQUMsUUFBUTBFLFVBQVV6RSxHQUFHO1FBQzlCSCxJQUFJSSxnQkFBZ0IsQ0FBQyxVQUFVO1FBQy9CSixJQUFJbUIsTUFBTSxDQUFDQyxVQUFVLEdBQUcsQ0FBQytCO1lBQ3JCeEQsS0FBS2tILGdCQUFnQixHQUFHO2dCQUNwQmhDLE1BQU1BLEtBQUtOLElBQUk7Z0JBQ2Z1QyxVQUFVM0QsRUFBRTVCLE1BQU0sR0FBRzRCLEVBQUUyRSxLQUFLLEdBQUc7WUFDbkM7UUFDSjtRQUNBOUgsSUFBSU8sTUFBTSxHQUFHLElBQUlULFFBQVE7Z0JBQ2pCVSxRQUFRUixJQUFJUSxNQUFNO1lBQ3RCO1FBQ0pSLElBQUlrQixPQUFPLEdBQUcsQ0FBQ0csSUFBSXRCLE9BQU9zQjtRQUMxQnJCLElBQUl5QixJQUFJLENBQUM0RjtJQUNiLEdBQUdGLEtBQUssQ0FBQyxPQUFPM0Q7UUFDWixNQUFNN0QsS0FBS3FFLGVBQWUsQ0FBQyxXQUFXO1lBQ2xDaUQsU0FBU3JDLFVBQVVrQixHQUFHO1lBQ3RCb0IsVUFBVTtZQUNWNUcsVUFBVXVFLEtBQUtOLElBQUk7WUFDbkJsQixTQUFTRyxNQUFNcEIsUUFBUTtRQUMzQjtRQUNBLE1BQU0sZUFBZSxrQ0FBa0M7SUFDM0Q7SUFDQSxJQUFJUSxTQUFTcEMsTUFBTSxHQUFHLE9BQU9vQyxTQUFTcEMsTUFBTSxHQUFHLEtBQUs7UUFDaEQsTUFBTWIsS0FBS3FFLGVBQWUsQ0FBQyxXQUFXO1lBQ2xDaUQsU0FBU3JDLFVBQVVrQixHQUFHO1lBQ3RCb0IsVUFBVTtZQUNWNUcsVUFBVXVFLEtBQUtOLElBQUk7UUFDdkI7SUFDSjtBQUNKO0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udGludWFsZy8uL25vZGVfbW9kdWxlcy91cGxvYWR0aGluZy9jbGllbnQvaW5kZXguanM/NmY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb250ZW50RGlzcG9zaXRpb24sIFVwbG9hZFRoaW5nRXJyb3IsIHNhZmVQYXJzZUpTT04sIHJlc29sdmVNYXliZVVybEFyZywgd2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJ0B1cGxvYWR0aGluZy9zaGFyZWQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVDbGllbnREcm9wem9uZUFjY2VwdCwgZ2VuZXJhdGVNaW1lVHlwZXMsIGdlbmVyYXRlUGVybWl0dGVkRmlsZVR5cGVzIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjYuNi4wXCI7XG5cbmNvbnN0IG1heWJlUGFyc2VSZXNwb25zZVhNTCA9IChtYXliZVhtbCk9PntcbiAgICBjb25zdCBjb2RlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPENvZGU+KC4qPyk8XFwvQ29kZT4vcyk7XG4gICAgY29uc3QgbWVzc2FnZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxNZXNzYWdlPiguKj8pPFxcL01lc3NhZ2U+L3MpO1xuICAgIGNvbnN0IGNvZGUgPSBjb2RlTWF0Y2g/LlsxXTtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZU1hdGNoPy5bMV07XG4gICAgaWYgKCFjb2RlIHx8ICFtZXNzYWdlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZVtjb2RlXSA/PyBERUZBVUxUX0VSUk9SX0NPREUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICB9O1xufTtcbi8qKlxuICogTWFwIFMzIGVycm9yIGNvZGVzIHRvIFVwbG9hZFRoaW5nIGVycm9yIGNvZGVzXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgUzMgZXJyb3IgY29kZXMsIGJhc2VkIG9uIHdoYXQgc2VlbWVkIG1vc3QgbGlrZWx5IHRvXG4gKiBvY2N1ciBpbiB1cGxvYWR0aGluZy4gRm9yIGEgZnVsbCBsaXN0IG9mIFMzIGVycm9yIGNvZGVzLCBzZWU6XG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9FcnJvclJlc3BvbnNlcy5odG1sXG4gKi8gY29uc3QgREVGQVVMVF9FUlJPUl9DT0RFID0gXCJVUExPQURfRkFJTEVEXCI7XG5jb25zdCBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSA9IHtcbiAgICBBY2Nlc3NEZW5pZWQ6IFwiRk9SQklEREVOXCIsXG4gICAgRW50aXR5VG9vU21hbGw6IFwiVE9PX1NNQUxMXCIsXG4gICAgRW50aXR5VG9vTGFyZ2U6IFwiVE9PX0xBUkdFXCIsXG4gICAgRXhwaXJlZFRva2VuOiBcIkZPUkJJRERFTlwiLFxuICAgIEluY29ycmVjdE51bWJlck9mRmlsZXNJblBvc3RSZXF1ZXN0OiBcIlRPT19NQU5ZX0ZJTEVTXCIsXG4gICAgSW50ZXJuYWxFcnJvcjogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICBLZXlUb29Mb25nRXJyb3I6IFwiS0VZX1RPT19MT05HXCIsXG4gICAgTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkOiBcIlRPT19MQVJHRVwiXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgY2xpZW50IHVwbG9hZHMgd2hlcmUgcHJvZ3Jlc3MgaXMgbmVlZGVkLlxuICogVXNlcyBYTUxIdHRwUmVxdWVzdC5cbiAqLyBhc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKG9wdHMsIHJldHJ5Q291bnQgPSAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBVVFwiLCBvcHRzLnVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIG9wdHMuZmlsZVR5cGUpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiwgY29udGVudERpc3Bvc2l0aW9uKG9wdHMuY29udGVudERpc3Bvc2l0aW9uLCBvcHRzLmZpbGVOYW1lKSk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldGFnID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiRXRhZ1wiKTtcbiAgICAgICAgICAgICAgICBldGFnID8gcmVzb2x2ZShldGFnKSA6IHJlamVjdChcIk5PIEVUQUdcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5Q291bnQgPCBvcHRzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBkZWxheSBiZWZvcmUgcmV0cnlpbmcgKGV4cG9uZW50aWFsIGJhY2tvZmYgY2FuIGJlIHVzZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnBvdygyLCByZXRyeUNvdW50KSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcyk9PnNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCArIDEpOyAvLyBSZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJNYXggcmV0cmllcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgIHhoci5vbmVycm9yID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZiBjYW4gYmUgdXNlZClcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogMTAwO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpPT5zZXRUaW1lb3V0KHJlcywgZGVsYXkpKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKG9wdHMsIHJldHJ5Q291bnQgKyAxKTsgLy8gUmV0cnkgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiTWF4IHJldHJpZXMgZXhjZWVkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBlLmxvYWRlZCAtIGxhc3RQcm9ncmVzcztcbiAgICAgICAgICAgIGxhc3RQcm9ncmVzcyArPSBkZWx0YTtcbiAgICAgICAgICAgIG9wdHMub25Qcm9ncmVzcyhkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKG9wdHMuY2h1bmspO1xuICAgIH0pO1xufVxuXG5jb25zdCBjcmVhdGVBUElSZXF1ZXN0VXJsID0gKGNvbmZpZyk9PntcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNvbmZpZy51cmwpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuc2VhcmNoKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJhY3Rpb25UeXBlXCIsIGNvbmZpZy5hY3Rpb25UeXBlKTtcbiAgICBxdWVyeVBhcmFtcy5zZXQoXCJzbHVnXCIsIGNvbmZpZy5zbHVnKTtcbiAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdXJsO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIFwiY2xpZW50XCIgZm9yIHJlcG9ydGluZyBldmVudHMgdG8gdGhlIFVwbG9hZFRoaW5nIHNlcnZlciB2aWEgdGhlIHVzZXIncyBBUEkgZW5kcG9pbnQuXG4gKiBFdmVudHMgYXJlIGhhbmRsZWQgaW4gXCIuL2hhbmRsZXIudHMgc3RhcnRpbmcgYXQgTDIwMFwiXG4gKi8gY29uc3QgY3JlYXRlVVRSZXBvcnRlciA9IChjZmcpPT57XG4gICAgcmV0dXJuIGFzeW5jICh0eXBlLCBwYXlsb2FkKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBjcmVhdGVBUElSZXF1ZXN0VXJsKHtcbiAgICAgICAgICAgIHVybDogY2ZnLnVybCxcbiAgICAgICAgICAgIHNsdWc6IGNmZy5lbmRwb2ludCxcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjdXN0b21IZWFkZXJzID0gdHlwZW9mIGNmZy5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyBjZmcuaGVhZGVycygpIDogY2ZnLmhlYWRlcnM7XG4gICAgICAgIGlmIChjdXN0b21IZWFkZXJzIGluc3RhbmNlb2YgUHJvbWlzZSkgY3VzdG9tSGVhZGVycyA9IGF3YWl0IGN1c3RvbUhlYWRlcnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2ZnLmZldGNoKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1wYWNrYWdlXCI6IGNmZy5wYWNrYWdlLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24kMSxcbiAgICAgICAgICAgICAgICAuLi5jdXN0b21IZWFkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwiZmFpbHVyZVwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2h5IGlzbid0IHRoaXMgbmFycm93ZWQgYXV0b21hdGljYWxseT9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1heWJlUGFyc2VSZXNwb25zZVhNTChwLnMzRXJyb3IgPz8gXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQ/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBwYXJzZWQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZWQubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byB1cGxvYWQgZmlsZSAke3AuZmlsZU5hbWV9IHRvIFMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcC5zM0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IFVwbG9hZFRoaW5nRXJyb3IuZnJvbVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzb25PckVycm9yID0gYXdhaXQgc2FmZVBhcnNlSlNPTihyZXNwb25zZSk7XG4gICAgICAgIGlmIChqc29uT3JFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGpzb25PckVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHJlc3BvbnNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbk9yRXJyb3I7XG4gICAgfTtcbn07XG5cbi8vIERvbid0IHdhbnQgdG8gc2hpcCBvdXIgbG9nZ2VyIHRvIHRoZSBjbGllbnQsIGtlZXAgc2l6ZSBkb3duXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuY29uc3QgdXBsb2FkRmlsZXNJbnRlcm5hbCA9IGFzeW5jIChlbmRwb2ludCwgb3B0cyk9PntcbiAgICAvLyBGaW5lIHRvIHVzZSBnbG9iYWwgZmV0Y2ggaW4gYnJvd3NlclxuICAgIGNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgIGNvbnN0IHJlcG9ydEV2ZW50VG9VVCA9IGNyZWF0ZVVUUmVwb3J0ZXIoe1xuICAgICAgICBlbmRwb2ludDogU3RyaW5nKGVuZHBvaW50KSxcbiAgICAgICAgdXJsOiBvcHRzLnVybCxcbiAgICAgICAgcGFja2FnZTogb3B0cy5wYWNrYWdlLFxuICAgICAgICBmZXRjaCxcbiAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzXG4gICAgfSk7XG4gICAgLy8gR2V0IHByZXNpZ25lZCBVUkwgZm9yIFMzIHVwbG9hZFxuICAgIGNvbnN0IHMzQ29ubmVjdGlvblJlcyA9IGF3YWl0IHJlcG9ydEV2ZW50VG9VVChcInVwbG9hZFwiLCB7XG4gICAgICAgIGlucHV0OiBcImlucHV0XCIgaW4gb3B0cyA/IG9wdHMuaW5wdXQgOiBudWxsLFxuICAgICAgICBmaWxlczogb3B0cy5maWxlcy5tYXAoKGYpPT4oe1xuICAgICAgICAgICAgICAgIG5hbWU6IGYubmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmLnNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogZi50eXBlXG4gICAgICAgICAgICB9KSlcbiAgICB9KTtcbiAgICBpZiAoIXMzQ29ubmVjdGlvblJlcyB8fCAhQXJyYXkuaXNBcnJheShzM0Nvbm5lY3Rpb25SZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gVVJMLiBIb3cgZGlkIHlvdSBldmVuIGdldCBoZXJlP1wiLFxuICAgICAgICAgICAgY2F1c2U6IHMzQ29ubmVjdGlvblJlc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZmlsZVVwbG9hZFByb21pc2VzID0gczNDb25uZWN0aW9uUmVzLm1hcChhc3luYyAocHJlc2lnbmVkKT0+e1xuICAgICAgICBjb25zdCBmaWxlID0gb3B0cy5maWxlcy5maW5kKChmKT0+Zi5uYW1lID09PSBwcmVzaWduZWQuZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBmaWxlIGZvdW5kIGZvciBwcmVzaWduZWQgVVJMXCIsIHByZXNpZ25lZCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJOT1RfRk9VTkRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogYEV4cGVjdGVkIGZpbGUgd2l0aCBuYW1lICR7cHJlc2lnbmVkLmZpbGVOYW1lfSBidXQgZ290ICcke29wdHMuZmlsZXMuam9pbihcIixcIil9J2BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMub25VcGxvYWRCZWdpbj8uKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFwidXJsc1wiIGluIHByZXNpZ25lZCkge1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIHJlcG9ydEV2ZW50VG9VVCxcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdhaXQgYSBiaXQgYXMgaXQncyB1bnNyZWFzb25hYmxlIHRvIGV4cGVjdCB0aGUgc2VydmVyIHRvIGJlIGRvbmUgYnkgbm93XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocik9PnNldFRpbWVvdXQociwgNzUwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRQcmVzaWduZWRQb3N0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIHJlcG9ydEV2ZW50VG9VVCxcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VydmVyRGF0YSA9IG51bGw7XG4gICAgICAgIGlmICghb3B0cy5za2lwUG9sbGluZykge1xuICAgICAgICAgICAgc2VydmVyRGF0YSA9IGF3YWl0IHdpdGhFeHBvbmVudGlhbEJhY2tvZmYoYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChwcmVzaWduZWQucG9sbGluZ1VybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBwcmVzaWduZWQucG9sbGluZ0p3dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbigocik9PnIuanNvbigpKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyA9PT0gXCJkb25lXCIgPyByZXMuY2FsbGJhY2tEYXRhIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIGtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVybDogXCJodHRwczovL3V0ZnMuaW8vZi9cIiArIHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBzZXJ2ZXJEYXRhOiBzZXJ2ZXJEYXRhLFxuICAgICAgICAgICAgY3VzdG9tSWQ6IHByZXNpZ25lZC5jdXN0b21JZFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlVXBsb2FkUHJvbWlzZXMpO1xufTtcbmNvbnN0IGdlblVwbG9hZGVyID0gKGluaXRPcHRzKT0+e1xuICAgIHJldHVybiAoZW5kcG9pbnQsIG9wdHMpPT4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICB1cGxvYWRGaWxlc0ludGVybmFsKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgdXJsOiByZXNvbHZlTWF5YmVVcmxBcmcoaW5pdE9wdHM/LnVybCksXG4gICAgICAgICAgICBwYWNrYWdlOiBpbml0T3B0cy5wYWNrYWdlXG4gICAgICAgIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZE11bHRpcGFydChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBsZXQgZXRhZ3M7XG4gICAgbGV0IHVwbG9hZGVkQnl0ZXMgPSAwO1xuICAgIHRyeSB7XG4gICAgICAgIGV0YWdzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJlc2lnbmVkLnVybHMubWFwKGFzeW5jICh1cmwsIGluZGV4KT0+e1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcHJlc2lnbmVkLmNodW5rU2l6ZSAqIGluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgcHJlc2lnbmVkLmNodW5rU2l6ZSwgZmlsZS5zaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIGVuZCk7XG4gICAgICAgICAgICBjb25zdCBldGFnID0gYXdhaXQgdXBsb2FkUGFydFdpdGhQcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IHByZXNpZ25lZC5jb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZmlsZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IDEwLFxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IChkZWx0YSk9PntcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRCeXRlcyArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IHVwbG9hZGVkQnl0ZXMgLyBmaWxlLnNpemUgKiAxMDA7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWc6IGV0YWcsXG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogaW5kZXggKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIHMzRXJyb3I6IGVycm9yLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IFwidW5yZWFjaGFibGVcIjsgLy8gZmFpbHVyZSBldmVudCB3aWxsIHRocm93IGZvciB1c1xuICAgIH1cbiAgICAvLyBUZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgdXBsb2FkIGlzIGNvbXBsZXRlXG4gICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJtdWx0aXBhcnQtY29tcGxldGVcIiwge1xuICAgICAgICB1cGxvYWRJZDogcHJlc2lnbmVkLnVwbG9hZElkLFxuICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICBldGFnc1xuICAgIH0pLmNhdGNoKChyZXMpPT57XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIsXG4gICAgICAgICAgICBjYXVzZTogcmVzXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgcHJlc2lnbmVkLnVybCk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAocCk9PntcbiAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHAubG9hZGVkIC8gcC50b3RhbCAqIDEwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmxvYWQgPSAoKT0+cmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSAoZSk9PnJlamVjdChlKTtcbiAgICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH0pLmNhdGNoKGFzeW5jIChlcnJvcik9PntcbiAgICAgICAgYXdhaXQgb3B0cy5yZXBvcnRFdmVudFRvVVQoXCJmYWlsdXJlXCIsIHtcbiAgICAgICAgICAgIGZpbGVLZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cGxvYWRJZDogbnVsbCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICBzM0Vycm9yOiBlcnJvci50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBcInVucmVhY2hhYmxlXCI7IC8vIGZhaWx1cmUgZXZlbnQgd2lsbCB0aHJvdyBmb3IgdXNcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID4gMjk5IHx8IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCkge1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBudWxsLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGdlblVwbG9hZGVyLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsiY29udGVudERpc3Bvc2l0aW9uIiwiVXBsb2FkVGhpbmdFcnJvciIsInNhZmVQYXJzZUpTT04iLCJyZXNvbHZlTWF5YmVVcmxBcmciLCJ3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZ2VuZXJhdGVDbGllbnREcm9wem9uZUFjY2VwdCIsImdlbmVyYXRlTWltZVR5cGVzIiwiZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMiLCJ2ZXJzaW9uJDEiLCJtYXliZVBhcnNlUmVzcG9uc2VYTUwiLCJtYXliZVhtbCIsImNvZGVNYXRjaCIsIm1hdGNoIiwibWVzc2FnZU1hdGNoIiwiY29kZSIsIm1lc3NhZ2UiLCJzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSIsIkRFRkFVTFRfRVJST1JfQ09ERSIsIkFjY2Vzc0RlbmllZCIsIkVudGl0eVRvb1NtYWxsIiwiRW50aXR5VG9vTGFyZ2UiLCJFeHBpcmVkVG9rZW4iLCJJbmNvcnJlY3ROdW1iZXJPZkZpbGVzSW5Qb3N0UmVxdWVzdCIsIkludGVybmFsRXJyb3IiLCJLZXlUb29Mb25nRXJyb3IiLCJNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQiLCJ1cGxvYWRQYXJ0V2l0aFByb2dyZXNzIiwib3B0cyIsInJldHJ5Q291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInVybCIsInNldFJlcXVlc3RIZWFkZXIiLCJmaWxlVHlwZSIsImZpbGVOYW1lIiwib25sb2FkIiwic3RhdHVzIiwiZXRhZyIsImdldFJlc3BvbnNlSGVhZGVyIiwibWF4UmV0cmllcyIsImRlbGF5IiwiTWF0aCIsInBvdyIsInJlcyIsInNldFRpbWVvdXQiLCJsYXN0UHJvZ3Jlc3MiLCJvbmVycm9yIiwidXBsb2FkIiwib25wcm9ncmVzcyIsImUiLCJkZWx0YSIsImxvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJzZW5kIiwiY2h1bmsiLCJjcmVhdGVBUElSZXF1ZXN0VXJsIiwiY29uZmlnIiwiVVJMIiwicXVlcnlQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJzZXQiLCJhY3Rpb25UeXBlIiwic2x1ZyIsInRvU3RyaW5nIiwiY3JlYXRlVVRSZXBvcnRlciIsImNmZyIsInR5cGUiLCJwYXlsb2FkIiwiZW5kcG9pbnQiLCJjdXN0b21IZWFkZXJzIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhY2thZ2UiLCJwIiwicGFyc2VkIiwiczNFcnJvciIsImNhdXNlIiwib2siLCJlcnJvciIsImZyb21SZXNwb25zZSIsImpzb25PckVycm9yIiwiRXJyb3IiLCJ2ZXJzaW9uIiwidXBsb2FkRmlsZXNJbnRlcm5hbCIsImdsb2JhbFRoaXMiLCJiaW5kIiwicmVwb3J0RXZlbnRUb1VUIiwiU3RyaW5nIiwiczNDb25uZWN0aW9uUmVzIiwiaW5wdXQiLCJmaWxlcyIsIm1hcCIsImYiLCJuYW1lIiwic2l6ZSIsIkFycmF5IiwiaXNBcnJheSIsImZpbGVVcGxvYWRQcm9taXNlcyIsInByZXNpZ25lZCIsImZpbGUiLCJmaW5kIiwiY29uc29sZSIsImpvaW4iLCJvblVwbG9hZEJlZ2luIiwidXBsb2FkTXVsdGlwYXJ0IiwiciIsInVwbG9hZFByZXNpZ25lZFBvc3QiLCJzZXJ2ZXJEYXRhIiwic2tpcFBvbGxpbmciLCJwb2xsaW5nVXJsIiwiYXV0aG9yaXphdGlvbiIsInBvbGxpbmdKd3QiLCJ0aGVuIiwianNvbiIsImNhbGxiYWNrRGF0YSIsInVuZGVmaW5lZCIsImtleSIsImN1c3RvbUlkIiwiYWxsIiwiZ2VuVXBsb2FkZXIiLCJpbml0T3B0cyIsImV0YWdzIiwidXBsb2FkZWRCeXRlcyIsInVybHMiLCJpbmRleCIsIm9mZnNldCIsImNodW5rU2l6ZSIsImVuZCIsIm1pbiIsInNsaWNlIiwicGVyY2VudCIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsInRhZyIsInBhcnROdW1iZXIiLCJmaWxlS2V5IiwidXBsb2FkSWQiLCJjYXRjaCIsImxvZyIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmllbGRzIiwiZm9yRWFjaCIsImsiLCJ2IiwiYXBwZW5kIiwidG90YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;