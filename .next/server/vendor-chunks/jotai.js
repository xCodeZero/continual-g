"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udGludWFsZy8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vcmVhY3QubWpzP2FjMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IFJlYWN0RXhwb3J0cywgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZHVjZXIsIHVzZUVmZmVjdCwgdXNlRGVidWdWYWx1ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXREZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5cbmNvbnN0IFN0b3JlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmNvbnN0IHVzZVN0b3JlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gIHJldHVybiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yZSkgfHwgc3RvcmUgfHwgZ2V0RGVmYXVsdFN0b3JlKCk7XG59O1xuY29uc3QgUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlbixcbiAgc3RvcmVcbn0pID0+IHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VSZWYoKTtcbiAgaWYgKCFzdG9yZSAmJiAhc3RvcmVSZWYuY3VycmVudCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdG9yZSgpO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFN0b3JlQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogc3RvcmUgfHwgc3RvcmVSZWYuY3VycmVudFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn07XG5cbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCB1c2UgPSBSZWFjdEV4cG9ydHMudXNlIHx8ICgocHJvbWlzZSkgPT4ge1xuICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgfSBlbHNlIHtcbiAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICh2KSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn0pO1xuZnVuY3Rpb24gdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3QgW1t2YWx1ZUZyb21SZWR1Y2VyLCBzdG9yZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcl0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2KSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICBpZiAoT2JqZWN0LmlzKHByZXZbMF0sIG5leHRWYWx1ZSkgJiYgcHJldlsxXSA9PT0gc3RvcmUgJiYgcHJldlsyXSA9PT0gYXRvbSkge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV4dFZhbHVlLCBzdG9yZSwgYXRvbV07XG4gICAgfSxcbiAgICB2b2lkIDAsXG4gICAgKCkgPT4gW3N0b3JlLmdldChhdG9tKSwgc3RvcmUsIGF0b21dXG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChzdG9yZUZyb21SZWR1Y2VyICE9PSBzdG9yZSB8fCBhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcigpO1xuICAgIHZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kZWxheTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YihhdG9tLCAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVyZW5kZXIsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVyZW5kZXIoKTtcbiAgICB9KTtcbiAgICByZXJlbmRlcigpO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfSwgW3N0b3JlLCBhdG9tLCBkZWxheV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIGlzUHJvbWlzZUxpa2UodmFsdWUpID8gdXNlKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZShvcHRpb25zKTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuc2V0KGF0b20sIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgW3N0b3JlLCBhdG9tXVxuICApO1xuICByZXR1cm4gc2V0QXRvbTtcbn1cblxuZnVuY3Rpb24gdXNlQXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIG9wdGlvbnMpLFxuICAgIC8vIFdlIGRvIHdyb25nIHR5cGUgYXNzZXJ0aW9uIGhlcmUsIHdoaWNoIHJlc3VsdHMgaW4gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKVxuICBdO1xufVxuXG5leHBvcnQgeyBQcm92aWRlciwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tLCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0RXhwb3J0cyIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwiY3JlYXRlRWxlbWVudCIsInVzZVJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlQ2FsbGJhY2siLCJnZXREZWZhdWx0U3RvcmUiLCJjcmVhdGVTdG9yZSIsIlN0b3JlQ29udGV4dCIsInVzZVN0b3JlIiwib3B0aW9ucyIsInN0b3JlIiwiUHJvdmlkZXIiLCJjaGlsZHJlbiIsInN0b3JlUmVmIiwiY3VycmVudCIsInZhbHVlIiwiaXNQcm9taXNlTGlrZSIsIngiLCJ0aGVuIiwidXNlIiwicHJvbWlzZSIsInN0YXR1cyIsInJlYXNvbiIsInYiLCJlIiwidXNlQXRvbVZhbHVlIiwiYXRvbSIsInZhbHVlRnJvbVJlZHVjZXIiLCJzdG9yZUZyb21SZWR1Y2VyIiwiYXRvbUZyb21SZWR1Y2VyIiwicmVyZW5kZXIiLCJwcmV2IiwibmV4dFZhbHVlIiwiZ2V0IiwiT2JqZWN0IiwiaXMiLCJkZWxheSIsInVuc3ViIiwic3ViIiwic2V0VGltZW91dCIsInVzZVNldEF0b20iLCJzZXRBdG9tIiwiYXJncyIsImVudiIsIk1PREUiLCJFcnJvciIsInNldCIsInVzZUF0b20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = defaultRead;\n        config.write = defaultWrite;\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nfunction defaultRead(get) {\n    return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n    return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a)=>atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingStack = [];\n    const pendingMap = /* @__PURE__ */ new WeakMap();\n    let storeListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        storeListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const addPendingDependent = (atom, atomState)=>{\n        atomState.d.forEach((_, a)=>{\n            var _a;\n            if (!pendingMap.has(a)) {\n                const aState = getAtomState(a);\n                (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(a);\n                pendingMap.set(a, [\n                    aState,\n                    /* @__PURE__ */ new Set()\n                ]);\n                if (aState) {\n                    addPendingDependent(a, aState);\n                }\n            }\n            pendingMap.get(a)[1].add(atom);\n        });\n    };\n    const setAtomState = (atom, atomState)=>{\n        var _a;\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = getAtomState(atom);\n        atomStateMap.set(atom, atomState);\n        if (!pendingMap.has(atom)) {\n            (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n            pendingMap.set(atom, [\n                prevAtomState,\n                /* @__PURE__ */ new Set()\n            ]);\n            addPendingDependent(atom, atomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies)=>{\n        const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && isSelfAtom(atom, a)) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies, true);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!force && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (isSelfAtom(atom, a)) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const addAtom = (atom)=>{\n        let mounted = mountedMap.get(atom);\n        if (!mounted) {\n            mounted = mountAtom(atom);\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const delAtom = (atom)=>{\n        const mounted = mountedMap.get(atom);\n        if (mounted && canUnmountAtom(atom, mounted)) {\n            unmountAtom(atom);\n        }\n    };\n    const recomputeDependents = (atom)=>{\n        const getDependents = (a)=>{\n            var _a, _b;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent)=>{\n                dependents.add(dependent);\n            });\n            return dependents;\n        };\n        const topsortedAtoms = new Array();\n        const markedAtoms = /* @__PURE__ */ new Set();\n        const visit = (n)=>{\n            if (markedAtoms.has(n)) {\n                return;\n            }\n            markedAtoms.add(n);\n            for (const m of getDependents(n)){\n                if (n !== m) {\n                    visit(m);\n                }\n            }\n            topsortedAtoms.push(n);\n        };\n        visit(atom);\n        const changedAtoms = /* @__PURE__ */ new Set([\n            atom\n        ]);\n        for(let i = topsortedAtoms.length - 1; i >= 0; --i){\n            const a = topsortedAtoms[i];\n            const prevAtomState = getAtomState(a);\n            if (!prevAtomState) {\n                continue;\n            }\n            let hasChangedDeps = false;\n            for (const dep of prevAtomState.d.keys()){\n                if (dep !== a && changedAtoms.has(dep)) {\n                    hasChangedDeps = true;\n                    break;\n                }\n            }\n            if (hasChangedDeps) {\n                const nextAtomState = readAtomState(a, true);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    changedAtoms.add(a);\n                }\n            }\n        }\n    };\n    const writeAtomState = (atom, ...args)=>{\n        let isSync = true;\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            let r;\n            if (isSelfAtom(atom, a)) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending([\n                    a\n                ]);\n                if (( false ? 0 : void 0) !== \"production\") {\n                    storeListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        isSync = false;\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        pendingStack.push(/* @__PURE__ */ new Set([\n            atom\n        ]));\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending(pendingStack.pop());\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            const aMounted = mountedMap.get(a);\n            if (aMounted) {\n                aMounted.t.add(atom);\n            } else {\n                if (a !== atom) {\n                    mountAtom(a, atom, queue);\n                }\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const unmountAtom = (atom)=>{\n        var _a;\n        const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mounted = mountedMap.get(a);\n                    if (mounted) {\n                        mounted.t.delete(atom);\n                        if (canUnmountAtom(a, mounted)) {\n                            unmountAtom(a);\n                        }\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            maybeUnmountAtomSet.add(a);\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n            }\n        });\n        depSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.add(atom);\n            } else if (mountedMap.has(atom)) {\n                mountAtom(a, atom);\n            }\n        });\n        maybeUnmountAtomSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted && canUnmountAtom(a, mounted)) {\n                unmountAtom(a);\n            }\n        });\n    };\n    const flushPending = (pendingAtoms)=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        const pending = [];\n        const collectPending = (pendingAtom)=>{\n            var _a;\n            if (!pendingMap.has(pendingAtom)) {\n                return;\n            }\n            const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n            pendingMap.delete(pendingAtom);\n            pending.push([\n                pendingAtom,\n                prevAtomState\n            ]);\n            dependents.forEach(collectPending);\n            (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a)=>collectPending(a));\n        };\n        pendingAtoms.forEach(collectPending);\n        pending.forEach(([atom, prevAtomState])=>{\n            const atomState = getAtomState(atom);\n            if (!atomState) {\n                if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n                return;\n            }\n            if (atomState !== prevAtomState) {\n                const mounted = mountedMap.get(atom);\n                if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                    mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                }\n                if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                    mounted.l.forEach((listener)=>listener());\n                    if (( false ? 0 : void 0) !== \"production\") {\n                        flushed.add(atom);\n                    }\n                }\n            }\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = addAtom(atom);\n        const flushed = flushPending([\n            atom\n        ]);\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            storeListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            delAtom(atom);\n            if (( false ? 0 : void 0) !== \"production\") {\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l, rev)=>{\n                if (rev !== 2) {\n                    throw new Error(\"The current StoreListener revision is 2.\");\n                }\n                storeListenersRev2.add(l);\n                return ()=>{\n                    storeListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                pendingStack.push(/* @__PURE__ */ new Set());\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending(pendingStack.pop());\n                storeListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nif (( false ? 0 : void 0) !== \"production\") {\n    if (typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__ === \"number\") {\n        ++globalThis.__NUMBER_OF_JOTAI_INSTANCES__;\n    } else {\n        globalThis.__NUMBER_OF_JOTAI_INSTANCES__ = 1;\n    }\n}\nconst getDefaultStore = ()=>{\n    if (!defaultStore) {\n        if (( false ? 0 : void 0) !== \"production\" && globalThis.__NUMBER_OF_JOTAI_INSTANCES__ !== 1) {\n            console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n        }\n        defaultStore = createStore();\n    }\n    return defaultStore;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQyxVQUFVLElBQU1GO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPRixTQUFTLFlBQVk7UUFDOUJHLE9BQU9ILElBQUksR0FBR0E7SUFDaEIsT0FBTztRQUNMRyxPQUFPRSxJQUFJLEdBQUdMO1FBQ2RHLE9BQU9ILElBQUksR0FBR007UUFDZEgsT0FBT0YsS0FBSyxHQUFHTTtJQUNqQjtJQUNBLElBQUlOLE9BQU87UUFDVEUsT0FBT0YsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTRyxZQUFZRSxHQUFHO0lBQ3RCLE9BQU9BLElBQUksSUFBSTtBQUNqQjtBQUNBLFNBQVNELGFBQWFDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQ2pDLE9BQU9ELElBQ0wsSUFBSSxFQUNKLE9BQU9DLFFBQVEsYUFBYUEsSUFBSUYsSUFBSSxJQUFJLEtBQUtFO0FBRWpEO0FBRUEsTUFBTUMsYUFBYSxDQUFDWixNQUFNYSxJQUFNYixLQUFLYyxXQUFXLEdBQUdkLEtBQUtjLFdBQVcsQ0FBQ0QsS0FBS0EsTUFBTWI7QUFDL0UsTUFBTWUsa0JBQWtCLENBQUNmLE9BQVMsVUFBVUE7QUFDNUMsTUFBTWdCLHlCQUF5QixDQUFDaEIsT0FBUyxDQUFDLENBQUNBLEtBQUtFLEtBQUs7QUFDckQsTUFBTWUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJQztBQUM3QyxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDdENKLGlCQUFpQlAsR0FBRyxDQUFDVSxTQUFTQztJQUM5QkQsUUFBUUUsS0FBSyxDQUFDLEtBQ2QsR0FBR0MsT0FBTyxDQUFDLElBQU1O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LENBQUM1SixJQUFNcUMsV0FBV3pDLEdBQUcsQ0FBQ0k7WUFDdkM2SixtQkFBbUIsQ0FBQ0g7Z0JBQ2xCcEgsYUFBYStFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSXpFO2dCQUN0QyxLQUFLLE1BQU0sQ0FBQ3pELE1BQU1xRixlQUFlLElBQUlrRixPQUFRO29CQUMzQyxJQUFJeEosZ0JBQWdCZixPQUFPO3dCQUN6Qm9GLHNCQUFzQnBGLE1BQU1xRjt3QkFDNUJtQyxvQkFBb0J4SDtvQkFDdEI7Z0JBQ0Y7Z0JBQ0EsTUFBTTRJLFVBQVVDLGFBQWExRixhQUFhNkYsR0FBRztnQkFDN0MzRixtQkFBbUJRLE9BQU8sQ0FDeEIsQ0FBQ3VELElBQU1BLEVBQUU7d0JBQUUwQixNQUFNO3dCQUFXRjtvQkFBUTtZQUV4QztRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xuSSxLQUFLc0c7UUFDTHJHLEtBQUttRztRQUNMc0QsS0FBS0Y7SUFDUDtBQUNGO0FBQ0EsSUFBSVU7QUFDSixJQUFJLENBQUMsTUFBZSxHQUFHLENBQW9CLEdBQUcsS0FBSyxPQUFPLGNBQWM7SUFDdEUsSUFBSSxPQUFPQyxXQUFXQyw2QkFBNkIsS0FBSyxVQUFVO1FBQ2hFLEVBQUVELFdBQVdDLDZCQUE2QjtJQUM1QyxPQUFPO1FBQ0xELFdBQVdDLDZCQUE2QixHQUFHO0lBQzdDO0FBQ0Y7QUFDQSxNQUFNQyxrQkFBa0I7SUFDdEIsSUFBSSxDQUFDSCxjQUFjO1FBQ2pCLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCQyxXQUFXQyw2QkFBNkIsS0FBSyxHQUFHO1lBQ3hIN0YsUUFBUUMsSUFBSSxDQUNWO1FBRUo7UUFDQTBGLGVBQWUzSDtJQUNqQjtJQUNBLE9BQU8ySDtBQUNUO0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udGludWFsZy8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vdmFuaWxsYS5tanM/OWI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQga2V5Q291bnQgPSAwO1xuZnVuY3Rpb24gYXRvbShyZWFkLCB3cml0ZSkge1xuICBjb25zdCBrZXkgPSBgYXRvbSR7KytrZXlDb3VudH1gO1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdG9TdHJpbmc6ICgpID0+IGtleVxuICB9O1xuICBpZiAodHlwZW9mIHJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbmZpZy5yZWFkID0gcmVhZDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuaW5pdCA9IHJlYWQ7XG4gICAgY29uZmlnLnJlYWQgPSBkZWZhdWx0UmVhZDtcbiAgICBjb25maWcud3JpdGUgPSBkZWZhdWx0V3JpdGU7XG4gIH1cbiAgaWYgKHdyaXRlKSB7XG4gICAgY29uZmlnLndyaXRlID0gd3JpdGU7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkKGdldCkge1xuICByZXR1cm4gZ2V0KHRoaXMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFdyaXRlKGdldCwgc2V0LCBhcmcpIHtcbiAgcmV0dXJuIHNldChcbiAgICB0aGlzLFxuICAgIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIiA/IGFyZyhnZXQodGhpcykpIDogYXJnXG4gICk7XG59XG5cbmNvbnN0IGlzU2VsZkF0b20gPSAoYXRvbSwgYSkgPT4gYXRvbS51bnN0YWJsZV9pcyA/IGF0b20udW5zdGFibGVfaXMoYSkgOiBhID09PSBhdG9tO1xuY29uc3QgaGFzSW5pdGlhbFZhbHVlID0gKGF0b20pID0+IFwiaW5pdFwiIGluIGF0b207XG5jb25zdCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tID0gKGF0b20pID0+ICEhYXRvbS53cml0ZTtcbmNvbnN0IGNhbmNlbFByb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBjYW5jZWwpID0+IHtcbiAgY2FuY2VsUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgY2FuY2VsKTtcbiAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gIH0pLmZpbmFsbHkoKCkgPT4gY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSkpO1xufTtcbmNvbnN0IGNhbmNlbFByb21pc2UgPSAocHJvbWlzZSwgbmV4dCkgPT4ge1xuICBjb25zdCBjYW5jZWwgPSBjYW5jZWxQcm9taXNlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKGNhbmNlbCkge1xuICAgIGNhbmNlbFByb21pc2VNYXAuZGVsZXRlKHByb21pc2UpO1xuICAgIGNhbmNlbChuZXh0KTtcbiAgfVxufTtcbmNvbnN0IHJlc29sdmVQcm9taXNlID0gKHByb21pc2UsIHZhbHVlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgcHJvbWlzZS52YWx1ZSA9IHZhbHVlO1xufTtcbmNvbnN0IHJlamVjdFByb21pc2UgPSAocHJvbWlzZSwgZSkgPT4ge1xuICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgcHJvbWlzZS5yZWFzb24gPSBlO1xufTtcbmNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeCkgPT4gdHlwZW9mICh4ID09IG51bGwgPyB2b2lkIDAgOiB4LnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc0VxdWFsQXRvbVZhbHVlID0gKGEsIGIpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgT2JqZWN0LmlzKGEudiwgYi52KTtcbmNvbnN0IGlzRXF1YWxBdG9tRXJyb3IgPSAoYSwgYikgPT4gISFhICYmIFwiZVwiIGluIGEgJiYgXCJlXCIgaW4gYiAmJiBPYmplY3QuaXMoYS5lLCBiLmUpO1xuY29uc3QgaGFzUHJvbWlzZUF0b21WYWx1ZSA9IChhKSA9PiAhIWEgJiYgXCJ2XCIgaW4gYSAmJiBhLnYgaW5zdGFuY2VvZiBQcm9taXNlO1xuY29uc3QgaXNFcXVhbFByb21pc2VBdG9tVmFsdWUgPSAoYSwgYikgPT4gXCJ2XCIgaW4gYSAmJiBcInZcIiBpbiBiICYmIGEudi5vcmlnICYmIGEudi5vcmlnID09PSBiLnYub3JpZztcbmNvbnN0IHJldHVybkF0b21WYWx1ZSA9IChhdG9tU3RhdGUpID0+IHtcbiAgaWYgKFwiZVwiIGluIGF0b21TdGF0ZSkge1xuICAgIHRocm93IGF0b21TdGF0ZS5lO1xuICB9XG4gIHJldHVybiBhdG9tU3RhdGUudjtcbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9ICgpID0+IHtcbiAgY29uc3QgYXRvbVN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IG1vdW50ZWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgcGVuZGluZ1N0YWNrID0gW107XG4gIGNvbnN0IHBlbmRpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgbGV0IHN0b3JlTGlzdGVuZXJzUmV2MjtcbiAgbGV0IG1vdW50ZWRBdG9tcztcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgc3RvcmVMaXN0ZW5lcnNSZXYyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBtb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBhZGRQZW5kaW5nRGVwZW5kZW50ID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMoYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICAoX2EgPSBwZW5kaW5nU3RhY2tbcGVuZGluZ1N0YWNrLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkKGEpO1xuICAgICAgICBwZW5kaW5nTWFwLnNldChhLCBbYVN0YXRlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXSk7XG4gICAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGEsIGFTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdNYXAuZ2V0KGEpWzFdLmFkZChhdG9tKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVN0YXRlID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhdG9tKSkge1xuICAgICAgKF9hID0gcGVuZGluZ1N0YWNrW3BlbmRpbmdTdGFjay5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFkZChhdG9tKTtcbiAgICAgIHBlbmRpbmdNYXAuc2V0KGF0b20sIFtwcmV2QXRvbVN0YXRlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXSk7XG4gICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpKSB7XG4gICAgICBjb25zdCBuZXh0ID0gXCJ2XCIgaW4gYXRvbVN0YXRlID8gYXRvbVN0YXRlLnYgaW5zdGFuY2VvZiBQcm9taXNlID8gYXRvbVN0YXRlLnYgOiBQcm9taXNlLnJlc29sdmUoYXRvbVN0YXRlLnYpIDogUHJvbWlzZS5yZWplY3QoYXRvbVN0YXRlLmUpO1xuICAgICAgaWYgKHByZXZBdG9tU3RhdGUudiAhPT0gbmV4dCkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKHByZXZBdG9tU3RhdGUudiwgbmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVEZXBlbmRlbmNpZXMgPSAoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcywga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IE1hcChcbiAgICAgIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcyA/IG5leHRBdG9tU3RhdGUuZCA6IG51bGxcbiAgICApO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgbmV4dERlcGVuZGVuY2llcy5mb3JFYWNoKChhU3RhdGUsIGEpID0+IHtcbiAgICAgIGlmICghYVN0YXRlICYmIGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgYVN0YXRlID0gbmV4dEF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUpO1xuICAgICAgICBpZiAobmV4dEF0b21TdGF0ZS5kLmdldChhKSAhPT0gYVN0YXRlKSB7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gYXRvbSBzdGF0ZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgbmV4dEF0b21TdGF0ZS5kLnNpemUgIT09IGRlcGVuZGVuY2llcy5zaXplKSB7XG4gICAgICBuZXh0QXRvbVN0YXRlLmQgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWUgPSAoYXRvbSwgdmFsdWUsIG5leHREZXBlbmRlbmNpZXMsIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGQ6IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICB2OiB2YWx1ZVxuICAgIH07XG4gICAgaWYgKG5leHREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhcbiAgICAgICAgYXRvbSxcbiAgICAgICAgbmV4dEF0b21TdGF0ZSxcbiAgICAgICAgbmV4dERlcGVuZGVuY2llcyxcbiAgICAgICAga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpICYmIGhhc1Byb21pc2VBdG9tVmFsdWUobmV4dEF0b21TdGF0ZSkgJiYgaXNFcXVhbFByb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRBdG9tU3RhdGUudiA9IHByZXZBdG9tU3RhdGUudjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWVPclByb21pc2UgPSAoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMsIGFib3J0UHJvbWlzZSkgPT4ge1xuICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgbGV0IGNvbnRpbnVlUHJvbWlzZTtcbiAgICAgIGNvbnN0IHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgIGlmICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSB8fCBwcmV2QXRvbVN0YXRlLnYgIT09IHByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZShcbiAgICAgICAgICBhdG9tLFxuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgbmV4dERlcGVuZGVuY2llc1xuICAgICAgICApO1xuICAgICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkgJiYgcHJldkF0b21TdGF0ZS5kICE9PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IHNldHRsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVPclByb21pc2UudGhlbihcbiAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcbiAgICAgICAgICAgICAgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZVByb21pc2UgPSAobmV4dCkgPT4ge1xuICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0LnRoZW4oXG4gICAgICAgICAgICAgICh2KSA9PiByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KSxcbiAgICAgICAgICAgICAgKGUpID0+IHJlamVjdFByb21pc2UocHJvbWlzZSwgZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZS5vcmlnID0gdmFsdWVPclByb21pc2U7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgcmVnaXN0ZXJDYW5jZWxQcm9taXNlKHByb21pc2UsIChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgY29udGludWVQcm9taXNlKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0UHJvbWlzZSA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRQcm9taXNlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgcHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMpO1xuICB9O1xuICBjb25zdCBzZXRBdG9tRXJyb3IgPSAoYXRvbSwgZXJyb3IsIG5leHREZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZTogZXJyb3JcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20sIGZvcmNlKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGlmICghZm9yY2UgJiYgYXRvbVN0YXRlKSB7XG4gICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5mcm9tKGF0b21TdGF0ZS5kKS5ldmVyeSgoW2EsIHNdKSA9PiB7XG4gICAgICAgIGlmIChhID09PSBhdG9tKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgcmV0dXJuIGFTdGF0ZSA9PT0gcyB8fCBpc0VxdWFsQXRvbVZhbHVlKGFTdGF0ZSwgcyk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0RGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKGFTdGF0ZTIpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUyKTtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCB2b2lkIDApO1xuICAgICAgICAgIHJldHVybiBhLmluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgfTtcbiAgICBsZXQgY29udHJvbGxlcjtcbiAgICBsZXQgc2V0U2VsZjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgICB9LFxuICAgICAgZ2V0IHNldFNlbGYoKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgd2l0aCByZWFkLW9ubHkgYXRvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldFNlbGYgJiYgaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIHNldFNlbGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3luYykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaW4gc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0U2VsZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZU9yUHJvbWlzZSA9IGF0b20ucmVhZChnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgdmFsdWVPclByb21pc2UsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEF0b21FcnJvcihhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYXRvbSkpO1xuICBjb25zdCBhZGRBdG9tID0gKGF0b20pID0+IHtcbiAgICBsZXQgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmICghbW91bnRlZCkge1xuICAgICAgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IGNhblVubW91bnRBdG9tID0gKGF0b20sIG1vdW50ZWQpID0+ICFtb3VudGVkLmwuc2l6ZSAmJiAoIW1vdW50ZWQudC5zaXplIHx8IG1vdW50ZWQudC5zaXplID09PSAxICYmIG1vdW50ZWQudC5oYXMoYXRvbSkpO1xuICBjb25zdCBkZWxBdG9tID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKG1vdW50ZWQgJiYgY2FuVW5tb3VudEF0b20oYXRvbSwgbW91bnRlZCkpIHtcbiAgICAgIHVubW91bnRBdG9tKGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVjb21wdXRlRGVwZW5kZW50cyA9IChhdG9tKSA9PiB7XG4gICAgY29uc3QgZ2V0RGVwZW5kZW50cyA9IChhKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IG5ldyBTZXQoKF9hID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50KTtcbiAgICAgIChfYiA9IHBlbmRpbmdNYXAuZ2V0KGEpKSA9PSBudWxsID8gdm9pZCAwIDogX2JbMV0uZm9yRWFjaCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICAgIGRlcGVuZGVudHMuYWRkKGRlcGVuZGVudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXBlbmRlbnRzO1xuICAgIH07XG4gICAgY29uc3QgdG9wc29ydGVkQXRvbXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBtYXJrZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaXQgPSAobikgPT4ge1xuICAgICAgaWYgKG1hcmtlZEF0b21zLmhhcyhuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrZWRBdG9tcy5hZGQobik7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgZ2V0RGVwZW5kZW50cyhuKSkge1xuICAgICAgICBpZiAobiAhPT0gbSkge1xuICAgICAgICAgIHZpc2l0KG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3Bzb3J0ZWRBdG9tcy5wdXNoKG4pO1xuICAgIH07XG4gICAgdmlzaXQoYXRvbSk7XG4gICAgY29uc3QgY2hhbmdlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKTtcbiAgICBmb3IgKGxldCBpID0gdG9wc29ydGVkQXRvbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGEgPSB0b3Bzb3J0ZWRBdG9tc1tpXTtcbiAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICBpZiAoIXByZXZBdG9tU3RhdGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgaGFzQ2hhbmdlZERlcHMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIHByZXZBdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gcmVhZEF0b21TdGF0ZShhLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgY2hhbmdlZEF0b21zLmFkZChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tU3RhdGUgPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhKSk7XG4gICAgY29uc3Qgc2V0dGVyID0gKGEsIC4uLmFyZ3MyKSA9PiB7XG4gICAgICBsZXQgcjtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXRvbSBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZU9yUHJvbWlzZShhLCBhcmdzMlswXSk7XG4gICAgICAgIGlmICghaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB3cml0ZUF0b21TdGF0ZShhLCAuLi5hcmdzMik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKFthXSk7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcImFzeW5jLXdyaXRlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF0b20ud3JpdGUoZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpO1xuICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZyhwZW5kaW5nU3RhY2sucG9wKCkpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgc3RvcmVMaXN0ZW5lcnNSZXYyLmZvckVhY2goKGwpID0+IGwoeyB0eXBlOiBcIndyaXRlXCIsIGZsdXNoZWQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCBtb3VudEF0b20gPSAoYXRvbSwgaW5pdGlhbERlcGVuZGVudCwgb25Nb3VudFF1ZXVlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHF1ZXVlID0gb25Nb3VudFF1ZXVlIHx8IFtdO1xuICAgIChfYSA9IGdldEF0b21TdGF0ZShhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChhTW91bnRlZCkge1xuICAgICAgICBhTW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhICE9PSBhdG9tKSB7XG4gICAgICAgICAgbW91bnRBdG9tKGEsIGF0b20sIHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbW91bnRlZCA9IHtcbiAgICAgIHQ6IG5ldyBTZXQoaW5pdGlhbERlcGVuZGVudCAmJiBbaW5pdGlhbERlcGVuZGVudF0pLFxuICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgbW91bnRlZE1hcC5zZXQoYXRvbSwgbW91bnRlZCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIH1cbiAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgIGNvbnN0IHsgb25Nb3VudCB9ID0gYXRvbTtcbiAgICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgICBjb25zdCBvblVubW91bnQgPSBvbk1vdW50KCguLi5hcmdzKSA9PiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncykpO1xuICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgbW91bnRlZC51ID0gb25Vbm1vdW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvbk1vdW50UXVldWUpIHtcbiAgICAgIHF1ZXVlLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCB1bm1vdW50QXRvbSA9IChhdG9tKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9uVW5tb3VudCA9IChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudTtcbiAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICBvblVubW91bnQoKTtcbiAgICB9XG4gICAgbW91bnRlZE1hcC5kZWxldGUoYXRvbSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUoYXRvbVN0YXRlKSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKGF0b21TdGF0ZS52KTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICBpZiAoY2FuVW5tb3VudEF0b20oYSwgbW91bnRlZCkpIHtcbiAgICAgICAgICAgICAgdW5tb3VudEF0b20oYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBjb3VsZCBub3QgZmluZCBhdG9tIHN0YXRlIHRvIHVubW91bnRcIiwgYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IChhdG9tLCBhdG9tU3RhdGUsIHByZXZEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBkZXBTZXQgPSBuZXcgU2V0KGF0b21TdGF0ZS5kLmtleXMoKSk7XG4gICAgY29uc3QgbWF5YmVVbm1vdW50QXRvbVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcHJldkRlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogcHJldkRlcGVuZGVuY2llcy5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICBpZiAoZGVwU2V0LmhhcyhhKSkge1xuICAgICAgICBkZXBTZXQuZGVsZXRlKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXliZVVubW91bnRBdG9tU2V0LmFkZChhKTtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVwU2V0LmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgIG1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICB9IGVsc2UgaWYgKG1vdW50ZWRNYXAuaGFzKGF0b20pKSB7XG4gICAgICAgIG1vdW50QXRvbShhLCBhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtYXliZVVubW91bnRBdG9tU2V0LmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChtb3VudGVkICYmIGNhblVubW91bnRBdG9tKGEsIG1vdW50ZWQpKSB7XG4gICAgICAgIHVubW91bnRBdG9tKGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaFBlbmRpbmcgPSAocGVuZGluZ0F0b21zKSA9PiB7XG4gICAgbGV0IGZsdXNoZWQ7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBmbHVzaGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGNvbGxlY3RQZW5kaW5nID0gKHBlbmRpbmdBdG9tKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXBlbmRpbmdNYXAuaGFzKHBlbmRpbmdBdG9tKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBbcHJldkF0b21TdGF0ZSwgZGVwZW5kZW50c10gPSBwZW5kaW5nTWFwLmdldChwZW5kaW5nQXRvbSk7XG4gICAgICBwZW5kaW5nTWFwLmRlbGV0ZShwZW5kaW5nQXRvbSk7XG4gICAgICBwZW5kaW5nLnB1c2goW3BlbmRpbmdBdG9tLCBwcmV2QXRvbVN0YXRlXSk7XG4gICAgICBkZXBlbmRlbnRzLmZvckVhY2goY29sbGVjdFBlbmRpbmcpO1xuICAgICAgKF9hID0gZ2V0QXRvbVN0YXRlKHBlbmRpbmdBdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuZm9yRWFjaCgoXywgYSkgPT4gY29sbGVjdFBlbmRpbmcoYSkpO1xuICAgIH07XG4gICAgcGVuZGluZ0F0b21zLmZvckVhY2goY29sbGVjdFBlbmRpbmcpO1xuICAgIHBlbmRpbmcuZm9yRWFjaCgoW2F0b20sIHByZXZBdG9tU3RhdGVdKSA9PiB7XG4gICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICBpZiAoIWF0b21TdGF0ZSkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBubyBhdG9tIHN0YXRlIHRvIGZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhdG9tU3RhdGUgIT09IHByZXZBdG9tU3RhdGUpIHtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBhdG9tU3RhdGUuZCAhPT0gKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBhdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIS8vIFRPRE8gVGhpcyBzZWVtcyBwcmV0dHkgaGFja3kuIEhvcGUgdG8gZml4IGl0LlxuICAgICAgICAvLyBNYXliZSB3ZSBjb3VsZCBgbW91bnREZXBlbmRlbmNpZXNgIGluIGBzZXRBdG9tU3RhdGVgP1xuICAgICAgICAoIWhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgKGlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSB8fCBpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIGF0b21TdGF0ZSkpKSkge1xuICAgICAgICAgIG1vdW50ZWQubC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSk7XG4gICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmbHVzaGVkLmFkZChhdG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmbHVzaGVkO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlQXRvbSA9IChhdG9tLCBsaXN0ZW5lcikgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBhZGRBdG9tKGF0b20pO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcoW2F0b21dKTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtb3VudGVkLmw7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBzdG9yZUxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInN1YlwiLCBmbHVzaGVkIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBkZWxBdG9tKGF0b20pO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKChsKSA9PiBsKHsgdHlwZTogXCJ1bnN1YlwiIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiByZWFkQXRvbSxcbiAgICAgIHNldDogd3JpdGVBdG9tLFxuICAgICAgc3ViOiBzdWJzY3JpYmVBdG9tLFxuICAgICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgICAgZGV2X3N1YnNjcmliZV9zdG9yZTogKGwsIHJldikgPT4ge1xuICAgICAgICBpZiAocmV2ICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgU3RvcmVMaXN0ZW5lciByZXZpc2lvbiBpcyAyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZUxpc3RlbmVyc1JldjIuYWRkKGwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGV2X2dldF9tb3VudGVkX2F0b21zOiAoKSA9PiBtb3VudGVkQXRvbXMudmFsdWVzKCksXG4gICAgICBkZXZfZ2V0X2F0b21fc3RhdGU6IChhKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGEpLFxuICAgICAgZGV2X2dldF9tb3VudGVkOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSksXG4gICAgICBkZXZfcmVzdG9yZV9hdG9tczogKHZhbHVlcykgPT4ge1xuICAgICAgICBwZW5kaW5nU3RhY2sucHVzaCgvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVPclByb21pc2VdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIHNldEF0b21WYWx1ZU9yUHJvbWlzZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKHBlbmRpbmdTdGFjay5wb3AoKSk7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJyZXN0b3JlXCIsIGZsdXNoZWQgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b21cbiAgfTtcbn07XG5sZXQgZGVmYXVsdFN0b3JlO1xuaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXyA9PT0gXCJudW1iZXJcIikge1xuICAgICsrZ2xvYmFsVGhpcy5fX05VTUJFUl9PRl9KT1RBSV9JTlNUQU5DRVNfXztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fID0gMTtcbiAgfVxufVxuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnbG9iYWxUaGlzLl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fICE9PSAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIl0sIm5hbWVzIjpbImtleUNvdW50IiwiYXRvbSIsInJlYWQiLCJ3cml0ZSIsImtleSIsImNvbmZpZyIsInRvU3RyaW5nIiwiaW5pdCIsImRlZmF1bHRSZWFkIiwiZGVmYXVsdFdyaXRlIiwiZ2V0Iiwic2V0IiwiYXJnIiwiaXNTZWxmQXRvbSIsImEiLCJ1bnN0YWJsZV9pcyIsImhhc0luaXRpYWxWYWx1ZSIsImlzQWN0dWFsbHlXcml0YWJsZUF0b20iLCJjYW5jZWxQcm9taXNlTWFwIiwiV2Vha01hcCIsInJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSIsInByb21pc2UiLCJjYW5jZWwiLCJjYXRjaCIsImZpbmFsbHkiLCJkZWxldGUiLCJjYW5jZWxQcm9taXNlIiwibmV4dCIsInJlc29sdmVQcm9taXNlIiwidmFsdWUiLCJzdGF0dXMiLCJyZWplY3RQcm9taXNlIiwiZSIsInJlYXNvbiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImlzRXF1YWxBdG9tVmFsdWUiLCJiIiwiT2JqZWN0IiwiaXMiLCJ2IiwiaXNFcXVhbEF0b21FcnJvciIsImhhc1Byb21pc2VBdG9tVmFsdWUiLCJQcm9taXNlIiwiaXNFcXVhbFByb21pc2VBdG9tVmFsdWUiLCJvcmlnIiwicmV0dXJuQXRvbVZhbHVlIiwiYXRvbVN0YXRlIiwiY3JlYXRlU3RvcmUiLCJhdG9tU3RhdGVNYXAiLCJtb3VudGVkTWFwIiwicGVuZGluZ1N0YWNrIiwicGVuZGluZ01hcCIsInN0b3JlTGlzdGVuZXJzUmV2MiIsIm1vdW50ZWRBdG9tcyIsImVudiIsIk1PREUiLCJTZXQiLCJnZXRBdG9tU3RhdGUiLCJhZGRQZW5kaW5nRGVwZW5kZW50IiwiZCIsImZvckVhY2giLCJfIiwiX2EiLCJoYXMiLCJhU3RhdGUiLCJsZW5ndGgiLCJhZGQiLCJzZXRBdG9tU3RhdGUiLCJmcmVlemUiLCJwcmV2QXRvbVN0YXRlIiwicmVzb2x2ZSIsInJlamVjdCIsInVwZGF0ZURlcGVuZGVuY2llcyIsIm5leHRBdG9tU3RhdGUiLCJuZXh0RGVwZW5kZW5jaWVzIiwia2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jaWVzIiwiTWFwIiwiY2hhbmdlZCIsImNvbnNvbGUiLCJ3YXJuIiwic2l6ZSIsInNldEF0b21WYWx1ZSIsInNldEF0b21WYWx1ZU9yUHJvbWlzZSIsInZhbHVlT3JQcm9taXNlIiwiYWJvcnRQcm9taXNlIiwiY29udGludWVQcm9taXNlIiwidXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyIsIm1vdW50RGVwZW5kZW5jaWVzIiwic2V0dGxlZCIsInNldEF0b21FcnJvciIsImVycm9yIiwicmVhZEF0b21TdGF0ZSIsImZvcmNlIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJzIiwiaXNTeW5jIiwiZ2V0dGVyIiwiYVN0YXRlMiIsIkVycm9yIiwiY29udHJvbGxlciIsInNldFNlbGYiLCJvcHRpb25zIiwic2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwiYXJncyIsIndyaXRlQXRvbSIsImFib3J0IiwicmVhZEF0b20iLCJhZGRBdG9tIiwibW91bnRlZCIsIm1vdW50QXRvbSIsImNhblVubW91bnRBdG9tIiwibCIsInQiLCJkZWxBdG9tIiwidW5tb3VudEF0b20iLCJyZWNvbXB1dGVEZXBlbmRlbnRzIiwiZ2V0RGVwZW5kZW50cyIsIl9iIiwiZGVwZW5kZW50cyIsImRlcGVuZGVudCIsInRvcHNvcnRlZEF0b21zIiwibWFya2VkQXRvbXMiLCJ2aXNpdCIsIm4iLCJtIiwicHVzaCIsImNoYW5nZWRBdG9tcyIsImkiLCJoYXNDaGFuZ2VkRGVwcyIsImRlcCIsImtleXMiLCJ3cml0ZUF0b21TdGF0ZSIsInNldHRlciIsImFyZ3MyIiwiciIsImZsdXNoZWQiLCJmbHVzaFBlbmRpbmciLCJ0eXBlIiwicmVzdWx0IiwicG9wIiwiaW5pdGlhbERlcGVuZGVudCIsIm9uTW91bnRRdWV1ZSIsInF1ZXVlIiwiYU1vdW50ZWQiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwidSIsImYiLCJwcmV2RGVwZW5kZW5jaWVzIiwiZGVwU2V0IiwibWF5YmVVbm1vdW50QXRvbVNldCIsInBlbmRpbmdBdG9tcyIsInBlbmRpbmciLCJjb2xsZWN0UGVuZGluZyIsInBlbmRpbmdBdG9tIiwibGlzdGVuZXIiLCJzdWJzY3JpYmVBdG9tIiwibGlzdGVuZXJzIiwic3ViIiwiZGV2X3N1YnNjcmliZV9zdG9yZSIsInJldiIsImRldl9nZXRfbW91bnRlZF9hdG9tcyIsInZhbHVlcyIsImRldl9nZXRfYXRvbV9zdGF0ZSIsImRldl9nZXRfbW91bnRlZCIsImRldl9yZXN0b3JlX2F0b21zIiwiZGVmYXVsdFN0b3JlIiwiZ2xvYmFsVGhpcyIsIl9fTlVNQkVSX09GX0pPVEFJX0lOU1RBTkNFU19fIiwiZ2V0RGVmYXVsdFN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;